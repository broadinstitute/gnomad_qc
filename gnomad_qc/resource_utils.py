import logging
from functools import reduce
from typing import Union

import hail as hl
from hail.linalg import BlockMatrix
from gnomad.resources.resource_utils import (
    BaseResource,
    BlockMatrixResource,
    DataException,
    MatrixTableResource,
    PedigreeResource,
    ResourceNotAvailable,
    TableResource,
    VariantDatasetResource,
)

logger = logging.getLogger("gnomad_qc.resource_utils")


GNOMAD_PRIVATE_BUCKETS = ("gnomad", "gnomad-tmp")
"""
Private buckets for gnomAD data.
"""


def check_resource_existence(
    resource: Union[str, BaseResource],
    raise_exist_no_overwrite_error: bool = False,
):
    if not isinstance(resource, str):
        resource = resource.path

    paths_to_test = [resource]
    if any(resource.endswith(ext) for ext in (".ht", ".mt", ".bm", ".parquet")):
        paths_to_test = [f"{resource}/_SUCCESS"]

    if resource.endswith(".vds"):
        paths_to_test = [
            f"{resource}/reference_data/_SUCCESS",
            f"{resource}/variant_data/_SUCCESS",
        ]

    exists = all(
        [hl.current_backend().fs.exists(path_to_test) for path_to_test in paths_to_test]
    )

    if exists and raise_exist_no_overwrite_error:
        raise DataException(
            f"{resource} already exists and the --overwrite option was not used!"
        )

    return exists


class GnomadPrivateResource(BaseResource):
    """Base class for the gnomAD project's private resources."""

    def _get_path(self, test: bool = False) -> str:
        if test:
            relative_path = reduce(
                lambda path, bucket: path[5 + len(bucket):]
                if path.startswith(f"gs://{bucket}/")
                else path,
                GNOMAD_PRIVATE_BUCKETS,
                self._path,
            )

            return f"gs://gnomad-tmp{relative_path}"
        else:
            return self._path

    def _set_path(self, path):
        if not any(
            path.startswith(f"gs://{bucket}/") for bucket in GNOMAD_PRIVATE_BUCKETS
        ):
            raise ValueError(
                f"GnomadPrivateResource requires a path to a file in one of the private gnomAD buckets ({', '.join(GNOMAD_PRIVATE_BUCKETS)})"
            )

        return super()._set_path(path)

    def get_path(self, test: bool = False):
        if test:
            return self.test_path
        else:
            return self.path

    test_path = property(
        fget=lambda self: self._get_path(test=True),
    )


class GnomadPrivateTableResource(TableResource, GnomadPrivateResource):
    """Resource class for a private Hail Table generated by gnomAD production."""

    def ht(self, force_import: bool = False, test: bool = False) -> hl.Table:
        """
        Read and return the Hail Table resource.

        :return: Hail Table resource
        """
        if self.path is None or force_import:
            return self.import_func(**self.import_args)
        elif test:
            return hl.read_table(self.test_path)
        else:
            return hl.read_table(self.path)


class GnomadPrivateMatrixTableResource(MatrixTableResource, GnomadPrivateResource):
    """Resource class for a private Hail MatrixTable generated by gnomAD production."""

    def mt(self, force_import: bool = False, test: bool = False) -> hl.MatrixTable:
        """
        Read and return the Hail MatrixTable resource.

        :return: Hail MatrixTable resource
        """
        if self.path is None or force_import:
            return self.import_func(**self.import_args)
        elif test:
            return hl.read_matrix_table(self.test_path)
        else:
            return hl.read_matrix_table(self.path)


class GnomadPrivatePedigreeResource(PedigreeResource, GnomadPrivateResource):
    """Resource class for a private pedigree generated by gnomAD production."""

    def ht(self, test: bool = False) -> hl.Table:
        """
        Read the pedigree into a family HT using hl.import_fam().

        :return: Family table
        """
        if test:
            path = self.test_path
        else:
            path = self.path

        return hl.import_fam(
            path,
            quant_pheno=self.quant_pheno,
            delimiter=self.delimiter,
            missing=self.missing,
        )

    def pedigree(self, test: bool = False) -> hl.Pedigree:
        """
        Read the pedigree into an hl.Pedigree using hl.Pedigree.read().

        :return: pedigree
        """
        if test:
            path = self.test_path
        else:
            path = self.path

        return hl.Pedigree.read(path, delimiter=self.delimiter)


class GnomadPrivateBlockMatrixResource(BlockMatrixResource, GnomadPrivateResource):
    """Resource class for a private Hail BlockMatrix generated by gnomAD production."""

    def bm(self, test: bool = False) -> BlockMatrix:
        """
        Read and return the Hail MatrixTable resource.

        :return: Hail MatrixTable resource
        """
        if test:
            path = self.test_path
        else:
            path = self.path

        return BlockMatrix.read(path)


class GnomadPrivateVariantDatasetResource(
    VariantDatasetResource, GnomadPrivateResource
):
    """Resource class for a private Hail VariantDataset generated by gnomAD production."""

    def vds(
        self, force_import: bool = False, test: bool = False
    ) -> hl.vds.VariantDataset:
        """
        Read and return the Hail VariantDataset resource.

        :return: Hail VariantDataset resource
        """
        if self.path is None or force_import:
            return self.import_func(**self.import_args)
        elif test:
            return hl.vds.read_vds(self.test_path)
        else:
            return hl.vds.read_vds(self.path)
