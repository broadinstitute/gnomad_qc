<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gnomad_qc.v4.assessment.calculate_per_sample_stats &mdash; gnomad_qc master documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
        <script src="https://unpkg.com/mermaid@10.2.0/dist/mermaid.min.js"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            gnomad_qc
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/broadinstitute/gnomad_qc/tags">Change Log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">gnomad_qc</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gnomad_qc.v4.assessment.calculate_per_sample_stats</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gnomad_qc.v4.assessment.calculate_per_sample_stats</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Script to get per-sample variant counts and aggregate sample statistics.</span>

<span class="sd">The following per-sample variant counts (including heterozygous, homozygous, non-ref, singletons etc.) can be calculated:</span>

<span class="sd">    - Total number of variants</span>
<span class="sd">    - Number of variants that pass all variant qc filters</span>
<span class="sd">    - Number of variants in UK Biobank capture regions</span>
<span class="sd">    - Number of variants in Broad capture regions</span>
<span class="sd">    - Number of variants in the intersect of UK Biobank and Broad capture regions</span>
<span class="sd">    - Number of variants in the union of UK Biobank and Broad capture regions</span>
<span class="sd">    - Number of rare variants (adj AF &lt;0.1%)</span>
<span class="sd">    - Number of loss-of-function variants</span>
<span class="sd">    - Number of missense variants</span>
<span class="sd">    - Number of synonymous variants</span>

<span class="sd">The following aggregate sample stats of all of the above per-sample counts can be</span>
<span class="sd">computed:</span>

<span class="sd">        - Mean</span>
<span class="sd">        - Quantiles (0.0, 0.25, 0.5, 0.75, 1.0)</span>

<span class="sd">Aggregated statistics can also be computed by ancestry.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">hail</span> <span class="k">as</span> <span class="nn">hl</span>
<span class="kn">from</span> <span class="nn">gnomad.assessment.summary_stats</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_summary_stats_csq_filter_expr</span><span class="p">,</span>
    <span class="n">get_summary_stats_filter_group_meta</span><span class="p">,</span>
    <span class="n">get_summary_stats_variant_filter_expr</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">gnomad.resources.resource_utils</span> <span class="kn">import</span> <span class="n">TableResource</span>
<span class="kn">from</span> <span class="nn">gnomad.sample_qc.sex</span> <span class="kn">import</span> <span class="n">adjusted_sex_ploidy_expr</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.annotations</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">annotate_with_ht</span><span class="p">,</span>
    <span class="n">fill_missing_key_combinations</span><span class="p">,</span>
    <span class="n">get_adj_expr</span><span class="p">,</span>
    <span class="n">missing_struct_expr</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.filtering</span> <span class="kn">import</span> <span class="n">filter_to_adj</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.slack</span> <span class="kn">import</span> <span class="n">slack_notifications</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.vep</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CSQ_CODING</span><span class="p">,</span>
    <span class="n">CSQ_NON_CODING</span><span class="p">,</span>
    <span class="n">LOF_CSQ_SET</span><span class="p">,</span>
    <span class="n">LOFTEE_LABELS</span><span class="p">,</span>
    <span class="n">filter_vep_transcript_csqs</span><span class="p">,</span>
    <span class="n">get_most_severe_consequence_for_summary</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">hail.genetics.allele_type</span> <span class="kn">import</span> <span class="n">AlleleType</span>
<span class="kn">from</span> <span class="nn">hail.methods.qc</span> <span class="kn">import</span> <span class="n">_qc_allele_type</span>
<span class="kn">from</span> <span class="nn">hail.utils</span> <span class="kn">import</span> <span class="n">new_temp_file</span>
<span class="kn">from</span> <span class="nn">hail.utils.misc</span> <span class="kn">import</span> <span class="n">divide_null</span>
<span class="kn">from</span> <span class="nn">hail.vds.sample_qc</span> <span class="kn">import</span> <span class="n">vmt_sample_qc</span>

<span class="kn">from</span> <span class="nn">gnomad_qc.resource_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">PipelineResourceCollection</span><span class="p">,</span>
    <span class="n">PipelineStepResourceCollection</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">gnomad_qc.slack_creds</span> <span class="kn">import</span> <span class="n">slack_token</span>
<span class="kn">from</span> <span class="nn">gnomad_qc.v3.utils</span> <span class="kn">import</span> <span class="n">hom_alt_depletion_fix</span>
<span class="kn">from</span> <span class="nn">gnomad_qc.v4.resources</span> <span class="kn">import</span> <span class="n">meta</span>
<span class="kn">from</span> <span class="nn">gnomad_qc.v4.resources.assessment</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_per_sample_counts</span><span class="p">,</span>
    <span class="n">get_summary_stats_filtering_groups</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">gnomad_qc.v4.resources.basics</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_checkpoint_path</span><span class="p">,</span>
    <span class="n">get_gnomad_v4_genomes_vds</span><span class="p">,</span>
    <span class="n">get_gnomad_v4_vds</span><span class="p">,</span>
    <span class="n">get_logging_path</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">gnomad_qc.v4.resources.release</span> <span class="kn">import</span> <span class="n">release_sites</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2"> (</span><span class="si">%(name)s</span><span class="s2"> </span><span class="si">%(lineno)s</span><span class="s2">): </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">datefmt</span><span class="o">=</span><span class="s2">&quot;%m/</span><span class="si">%d</span><span class="s2">/%Y %I:%M:%S %p&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;per_sample_stats&quot;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="c1"># V4 has no OS in LOFTEE_LABELS.</span>
<span class="n">LOFTEE_LABELS</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">LOFTEE_LABELS</span><span class="p">)</span>
<span class="n">LOFTEE_LABELS</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;OS&quot;</span><span class="p">)</span>

<span class="n">SUM_STAT_FILTERS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;variant_qc&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;pass&quot;</span><span class="p">],</span>  <span class="c1"># Quality control status of the variant.</span>
    <span class="s2">&quot;capture&quot;</span><span class="p">:</span> <span class="p">[</span>  <span class="c1"># Capture methods used.</span>
        <span class="s2">&quot;ukb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;broad&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ukb_broad_intersect&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ukb_broad_union&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s2">&quot;max_af&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">],</span>  <span class="c1"># Maximum allele frequency thresholds.</span>
    <span class="s2">&quot;csq_set&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;lof&quot;</span><span class="p">,</span> <span class="s2">&quot;coding&quot;</span><span class="p">,</span> <span class="s2">&quot;non_coding&quot;</span><span class="p">],</span>  <span class="c1"># Consequence sets.</span>
    <span class="s2">&quot;lof_csq&quot;</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">LOF_CSQ_SET</span><span class="p">),</span>  <span class="c1"># Loss-of-function consequence set.</span>
    <span class="s2">&quot;csq&quot;</span><span class="p">:</span> <span class="p">[</span>  <span class="c1"># Additional consequence types.</span>
        <span class="s2">&quot;missense_variant&quot;</span><span class="p">,</span>
        <span class="s2">&quot;synonymous_variant&quot;</span><span class="p">,</span>
        <span class="s2">&quot;intron_variant&quot;</span><span class="p">,</span>
        <span class="s2">&quot;intergenic_variant&quot;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Dictionary of default filter settings for summary stats.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">COMMON_FILTERS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;variant_qc&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;pass&quot;</span><span class="p">],</span> <span class="s2">&quot;capture&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;ukb_broad_intersect&quot;</span><span class="p">]}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Dictionary of common filter settings to use for most summary stats.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">COMMON_FILTER_COMBOS</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;variant_qc&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;variant_qc&quot;</span><span class="p">,</span> <span class="s2">&quot;capture&quot;</span><span class="p">]]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">List of common variant filter combinations to use for summary stats.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">LOF_FILTERS_FOR_COMBO</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;lof_csq_set&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;lof&quot;</span><span class="p">],</span>  <span class="c1"># Loss-of-function consequence set.</span>
    <span class="s2">&quot;loftee_label&quot;</span><span class="p">:</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">LOFTEE_LABELS</span><span class="p">),</span>  <span class="c1"># LOFTEE loss-of-function labels.</span>
    <span class="s2">&quot;loftee_HC&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;HC&quot;</span><span class="p">],</span>  <span class="c1"># High-confidence LOFTEE label.</span>
    <span class="s2">&quot;loftee_flags&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;no_flags&quot;</span><span class="p">,</span> <span class="s2">&quot;with_flags&quot;</span><span class="p">],</span>  <span class="c1"># High-confidence LOFTEE flag options.</span>
<span class="p">}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Dictionary of an additional filter group to use for loss-of-function filter</span>
<span class="sd">combinations.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">LOF_FILTER_COMBOS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s2">&quot;lof_csq&quot;</span><span class="p">,</span> <span class="s2">&quot;loftee_label&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;lof_csq_set&quot;</span><span class="p">,</span> <span class="s2">&quot;loftee_label&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;lof_csq_set&quot;</span><span class="p">,</span> <span class="s2">&quot;loftee_HC&quot;</span><span class="p">,</span> <span class="s2">&quot;loftee_flags&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;lof_csq&quot;</span><span class="p">,</span> <span class="s2">&quot;loftee_HC&quot;</span><span class="p">,</span> <span class="s2">&quot;loftee_flags&quot;</span><span class="p">],</span>
<span class="p">]</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">List of loss-of-function consequence combinations to use for summary stats.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">MAP_FILTER_FIELD_TO_META</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;lof_csq&quot;</span><span class="p">:</span> <span class="s2">&quot;csq&quot;</span><span class="p">,</span>
    <span class="s2">&quot;loftee_HC&quot;</span><span class="p">:</span> <span class="s2">&quot;loftee_label&quot;</span><span class="p">,</span>
    <span class="s2">&quot;lof_csq_set&quot;</span><span class="p">:</span> <span class="s2">&quot;csq_set&quot;</span><span class="p">,</span>
<span class="p">}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Dictionary to rename keys in `SUM_STAT_FILTERS`, `COMMON_FILTERS`, or</span>
<span class="sd">`LOF_FILTERS_FOR_COMBO` to final metadata keys.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">ALLELE_TYPE_MAP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;insertion&quot;</span><span class="p">:</span> <span class="n">AlleleType</span><span class="o">.</span><span class="n">INSERTION</span><span class="p">,</span>
    <span class="s2">&quot;deletion&quot;</span><span class="p">:</span> <span class="n">AlleleType</span><span class="o">.</span><span class="n">DELETION</span><span class="p">,</span>
    <span class="s2">&quot;transition&quot;</span><span class="p">:</span> <span class="n">AlleleType</span><span class="o">.</span><span class="n">TRANSITION</span><span class="p">,</span>
    <span class="s2">&quot;transversion&quot;</span><span class="p">:</span> <span class="n">AlleleType</span><span class="o">.</span><span class="n">TRANSVERSION</span><span class="p">,</span>
    <span class="s2">&quot;star&quot;</span><span class="p">:</span> <span class="n">AlleleType</span><span class="o">.</span><span class="n">STAR</span><span class="p">,</span>
<span class="p">}</span>


<div class="viewcode-block" id="process_test_args"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.process_test_args">[docs]</a><span class="k">def</span> <span class="nf">process_test_args</span><span class="p">(</span>
    <span class="n">data_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">test_dataset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">test_gene</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">test_partitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">test_difficult_partitions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">create_filter_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">create_intermediate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">create_per_sample_counts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">use_intermediate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">sex_chr_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">autosomes_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">tinterval</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process test arguments for the per-sample stats pipeline.</span>

<span class="sd">    Return the intervals and partitions to filter to for testing or raise a ValueError</span>
<span class="sd">    if the test argument combination is invalid.</span>

<span class="sd">    The test argument combination is invalid if:</span>

<span class="sd">        - `create_filter_group` is True, and:</span>

<span class="sd">            - `test_partitions` and `create_per_sample_counts` are both True because the</span>
<span class="sd">              partitions in the release HT and the raw VDS are different.</span>
<span class="sd">            - `test_difficult_partitions` is True because difficult partitions are only</span>
<span class="sd">              relevant for testing per-sample counts.</span>
<span class="sd">            - `test_dataset` is True and `create_per_sample_counts` is False because the</span>
<span class="sd">              test dataset is only relevant when testing per-sample counts.</span>

<span class="sd">        - `test_difficult_partitions` is True, and:</span>

<span class="sd">            - `data_type` is &quot;genomes&quot; because difficult partitions are only relevant for</span>
<span class="sd">              the raw exome VDS.</span>
<span class="sd">            - `test_dataset` or `test_partitions` is True because difficult partitions</span>
<span class="sd">              only apply to the full exomes VDS.</span>

<span class="sd">        - `test_gene` is True, and `test_partitions` or `test_difficult_partitions` is</span>
<span class="sd">          True because there is no (or likely no) overlap in partitions between the</span>
<span class="sd">          gene test intervals and the test partitions or difficult partitions.</span>

<span class="sd">    :param data_type: Data type of the dataset.</span>
<span class="sd">    :param test_dataset: Boolean indicating whether to use the test dataset instead of</span>
<span class="sd">        the full dataset. Default is False.</span>
<span class="sd">    :param test_gene: Boolean indicating whether to filter the dataset to PCSK9 and/or</span>
<span class="sd">        TRPC5 and ZFY (depends on values of `sex_chr_only` and `autosomes_only` because</span>
<span class="sd">        PCSK9 is on chr1 and TRPC5 is on chrX and ZFY is on chrY). Default is False.</span>
<span class="sd">    :param test_partitions: Optional list of partitions to test on. Default is None.</span>
<span class="sd">    :param test_difficult_partitions: Boolean indicating whether to test on difficult</span>
<span class="sd">        partitions. For exomes only. Default is False.</span>
<span class="sd">    :param create_filter_group: Boolean indicating whether the filter group HT is being</span>
<span class="sd">        created. Default is False.</span>
<span class="sd">    :param create_intermediate: Boolean indicating whether the intermediate MT is being</span>
<span class="sd">        created. Default is False.</span>
<span class="sd">    :param create_per_sample_counts: Boolean indicating whether the per-sample counts HT</span>
<span class="sd">        is being created. Default is False.</span>
<span class="sd">    :param use_intermediate: Boolean indicating whether the intermediate MT is being</span>
<span class="sd">        used. Default is False.</span>
<span class="sd">    :param sex_chr_only: Boolean indicating whether the dataset is being filtered to</span>
<span class="sd">        sex chromosomes only. Default is False.</span>
<span class="sd">    :param autosomes_only: Boolean indicating whether the dataset is being filtered to</span>
<span class="sd">        autosomes only. Default is False.</span>
<span class="sd">    :return: Tuple of filter intervals and partitions to filter to for testing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">create_filter_group</span><span class="p">:</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">test_partitions</span> <span class="ow">and</span> <span class="n">create_per_sample_counts</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Cannot test on a custom number of partitions (--test-n-partitions) &quot;</span>
                <span class="s2">&quot;when using both --create-filter-group-ht and &quot;</span>
                <span class="s2">&quot;--create-per-sample-counts-ht because there is not an overlap in &quot;</span>
                <span class="s2">&quot;partitions.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">test_difficult_partitions</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Difficult partitions (--test-difficult-partitions) are only chosen &quot;</span>
                <span class="s2">&quot;for testing per-sample counts, we recommend using only --test-gene to &quot;</span>
                <span class="s2">&quot;test that --create-filter-group-ht is working as expected.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">test_dataset</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">create_per_sample_counts</span> <span class="ow">or</span> <span class="n">create_intermediate</span><span class="p">):</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;The use of the test VDS (--test-dataset) is only relevant when also&quot;</span>
                <span class="s2">&quot; testing per-sample counts (--create-intermediate-mt-for-sample-counts&quot;</span>
                <span class="s2">&quot;and/or --create-per-sample-counts-ht), we recommend using only &quot;</span>
                <span class="s2">&quot;--test-gene to test that --create-filter-group-ht is working as &quot;</span>
                <span class="s2">&quot;expected.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">err_msg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="n">err_msg</span> <span class="o">+</span> <span class="s2">&quot; For a quick test of both --create-filter-group-ht and &quot;</span>
                <span class="s2">&quot;--create-per-sample-counts-ht, use &#39;--test-gene --test-dataset&#39;. &quot;</span>
                <span class="s2">&quot;The full run of the --create-filter-group-ht step is relatively &quot;</span>
                <span class="s2">&quot;quick and once tests are complete on the filter group creation, &quot;</span>
                <span class="s2">&quot;the full run of --create-filter-group-ht should be done to further&quot;</span>
                <span class="s2">&quot; test --create-per-sample-counts-ht for memory errors.&quot;</span>
            <span class="p">)</span>

    <span class="c1"># The following four exome partitions have given us trouble with out-of-memory</span>
    <span class="c1"># errors in the past. We are testing on these partitions to ensure that the</span>
    <span class="c1"># per-sample stats script can handle them before running the entire dataset.</span>
    <span class="k">if</span> <span class="n">test_difficult_partitions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;genomes&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Difficult partitions for testing have only been chosen for exomes.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">test_dataset</span> <span class="ow">or</span> <span class="n">test_partitions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot test on difficult partitions (--test-difficult-partitions) and &quot;</span>
                <span class="s2">&quot;test dataset (--test-dataset) or a custom number of partitions &quot;</span>
                <span class="s2">&quot;(--test-n-partitions) at the same time. Difficult partitions only &quot;</span>
                <span class="s2">&quot;apply to the full exomes VDS.&quot;</span>
            <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Testing on difficult exome partitions to make sure the tests can pass &quot;</span>
            <span class="s2">&quot;without memory errors...&quot;</span>
        <span class="p">)</span>
        <span class="n">test_partitions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20180</span><span class="p">,</span> <span class="mi">40916</span><span class="p">,</span> <span class="mi">41229</span><span class="p">,</span> <span class="mi">46085</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">test_gene</span> <span class="ow">and</span> <span class="n">test_partitions</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot use --test-gene and --test-n-partitions or &quot;</span>
            <span class="s2">&quot;--test-difficult-partitions at the same time.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">create_intermediate</span>
        <span class="ow">or</span> <span class="p">(</span><span class="n">create_per_sample_counts</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_intermediate</span><span class="p">)</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">test_gene</span>
    <span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;This test requires that the full filtering groups Table has been &quot;</span>
            <span class="s2">&quot;created. Please run --create-filter-group-ht without &quot;</span>
            <span class="s2">&quot;--test-gene or --test-n-partitions if it doesn&#39;t already exist.&quot;</span>
        <span class="p">)</span>

    <span class="n">filter_intervals</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">test_gene</span><span class="p">:</span>
        <span class="n">filter_intervals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sex_chr_only</span><span class="p">:</span>
            <span class="c1"># Filter to 10kb in PCSK9.</span>
            <span class="n">filter_intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;chr1:55039447-55064852&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">autosomes_only</span><span class="p">:</span>
            <span class="c1"># Filter to TRPC5 on chrX and ZFY on chrY.</span>
            <span class="n">filter_intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;chrX:111776000-111786000&quot;</span><span class="p">,</span> <span class="s2">&quot;chrY:2935281-2982506&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">filter_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">parse_locus_interval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">reference_genome</span><span class="o">=</span><span class="s2">&quot;GRCh38&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">filter_intervals</span>
        <span class="p">]</span>

    <span class="k">return</span> <span class="n">filter_intervals</span><span class="p">,</span> <span class="n">test_partitions</span></div>


<div class="viewcode-block" id="get_capture_filter_exprs"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.get_capture_filter_exprs">[docs]</a><span class="k">def</span> <span class="nf">get_capture_filter_exprs</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">ukb_capture</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">broad_capture</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get filter expressions for UK Biobank and Broad capture regions.</span>

<span class="sd">    :param ht: Table containing variant annotations. The following annotations are</span>
<span class="sd">        required: &#39;region_flags&#39;.</span>
<span class="sd">    :param ukb_capture: Expression for variants that are in UKB capture intervals.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    :param broad_capture: Expression for variants that are in Broad capture intervals.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    :return: Dictionary of filter expressions for UK Biobank and Broad capture regions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_expr</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">log_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">ukb_capture</span><span class="p">:</span>
        <span class="n">log_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;variants in UK Biobank capture regions&quot;</span><span class="p">)</span>
        <span class="n">filter_expr</span><span class="p">[</span><span class="s2">&quot;capture_ukb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">ht</span><span class="o">.</span><span class="n">region_flags</span><span class="o">.</span><span class="n">outside_ukb_capture_region</span>

    <span class="k">if</span> <span class="n">broad_capture</span><span class="p">:</span>
        <span class="n">log_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;variants in Broad capture regions&quot;</span><span class="p">)</span>
        <span class="n">filter_expr</span><span class="p">[</span><span class="s2">&quot;capture_broad&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">ht</span><span class="o">.</span><span class="n">region_flags</span><span class="o">.</span><span class="n">outside_broad_capture_region</span>

    <span class="k">if</span> <span class="n">ukb_capture</span> <span class="ow">and</span> <span class="n">broad_capture</span><span class="p">:</span>
        <span class="n">log_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;variants in the intersect of UKB and Broad capture regions&quot;</span><span class="p">)</span>
        <span class="n">filter_expr</span><span class="p">[</span><span class="s2">&quot;capture_ukb_broad_intersect&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">filter_expr</span><span class="p">[</span><span class="s2">&quot;capture_ukb&quot;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">filter_expr</span><span class="p">[</span><span class="s2">&quot;capture_broad&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">log_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;variants in the union of UKB and Broad capture regions&quot;</span><span class="p">)</span>
        <span class="n">filter_expr</span><span class="p">[</span><span class="s2">&quot;capture_ukb_broad_union&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">filter_expr</span><span class="p">[</span><span class="s2">&quot;capture_ukb&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">filter_expr</span><span class="p">[</span><span class="s2">&quot;capture_broad&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Adding filtering for:</span><span class="se">\n\t</span><span class="si">%s</span><span class="s2">...&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">log_list</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">filter_expr</span></div>


<div class="viewcode-block" id="get_summary_stats_filter_groups_ht"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.get_summary_stats_filter_groups_ht">[docs]</a><span class="k">def</span> <span class="nf">get_summary_stats_filter_groups_ht</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">capture_regions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">vep_canonical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">vep_mane</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">rare_variants_afs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rare_variants_grpmax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rare_variant_mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create Table annotated with an array of booleans indicating whether a variant belongs to certain filter groups.</span>

<span class="sd">    A &#39;filter_groups&#39; annotation is added to the Table containing an ArrayExpression of</span>
<span class="sd">    BooleanExpressions for the following filter groups:</span>

<span class="sd">        - All variants</span>
<span class="sd">        - Variants that pass all variant QC filters</span>
<span class="sd">        - Variants in UK Biobank capture regions</span>
<span class="sd">        - Variants in Broad capture regions</span>
<span class="sd">        - Variants in the intersect of UK Biobank and Broad capture regions</span>
<span class="sd">        - Variants in the union of UK Biobank and Broad capture regions</span>
<span class="sd">        - Variant consequence: loss-of-function, missense, and synonymous</span>
<span class="sd">        - Rare variants with allele frequencies less than the thresholds in</span>
<span class="sd">          `rare_variants_afs`</span>

<span class="sd">    A &#39;filter_group_meta&#39; global annotation is added to the Table containing an array</span>
<span class="sd">    of dictionaries detailing the filters used in each filter group.</span>

<span class="sd">    :param ht: Table containing variant annotations. The following annotations are</span>
<span class="sd">        required: &#39;freq&#39;, &#39;filters&#39;, &#39;region_flags&#39;, and &#39;vep&#39;.</span>
<span class="sd">    :param capture_regions: Whether to include filtering groups for variants in UK</span>
<span class="sd">        Biobank and Broad capture regions. Default is False.</span>
<span class="sd">    :param vep_canonical: Whether to filter to only canonical transcripts. If trying</span>
<span class="sd">        count variants in all transcripts, set it to False. Default is True.</span>
<span class="sd">    :param vep_mane: Whether to filter to only MANE transcripts. Default is False.</span>
<span class="sd">    :param rare_variants_afs: Optional list of allele frequency thresholds to use for</span>
<span class="sd">        rare variant filtering.</span>
<span class="sd">    :param rare_variants_grpmax: Optional list of grpmax thresholds to use for rare</span>
<span class="sd">        variant filtering.</span>
<span class="sd">    :param rare_variant_mode: Whether to only include the rare variant filter groups</span>
<span class="sd">        and variant_qc as the common filter groups. Default is False.</span>
<span class="sd">    :return: Table containing an ArrayExpression of filter groups for summary stats.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rare_variant_mode</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rare_variants_afs</span> <span class="ow">or</span> <span class="n">rare_variants_grpmax</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;If rare_variant_mode is True, then at least one of rare_variants_afs or &quot;</span>
            <span class="s2">&quot;rare_variants_grpmax must be provided.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Filter to only canonical or MANE transcripts if requested and get the most</span>
    <span class="c1"># severe consequence for each variant.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">filter_vep_transcript_csqs</span><span class="p">(</span>
        <span class="n">ht</span><span class="p">,</span>
        <span class="n">synonymous</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">canonical</span><span class="o">=</span><span class="n">vep_canonical</span><span class="p">,</span>
        <span class="n">mane_select</span><span class="o">=</span><span class="n">vep_mane</span><span class="p">,</span>
        <span class="n">filter_empty_csq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">get_most_severe_consequence_for_summary</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span>

    <span class="c1"># Create filter expressions for the consequence types.</span>
    <span class="n">csq_filter_expr</span> <span class="o">=</span> <span class="n">get_summary_stats_csq_filter_expr</span><span class="p">(</span>
        <span class="n">ht</span><span class="p">,</span>
        <span class="n">lof_csq_set</span><span class="o">=</span><span class="n">LOF_CSQ_SET</span><span class="p">,</span>
        <span class="n">lof_label_set</span><span class="o">=</span><span class="n">LOFTEE_LABELS</span><span class="p">,</span>
        <span class="n">lof_no_flags</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">lof_any_flags</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">additional_csq_sets</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;coding&quot;</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">CSQ_CODING</span><span class="p">),</span>
            <span class="s2">&quot;non_coding&quot;</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">CSQ_NON_CODING</span><span class="p">),</span>
        <span class="p">},</span>
        <span class="n">additional_csqs</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">SUM_STAT_FILTERS</span><span class="p">[</span><span class="s2">&quot;csq&quot;</span><span class="p">]),</span>
    <span class="p">)</span>

    <span class="c1"># Create filter expressions for LCR, variant QC filters, and rare variant AFs if</span>
    <span class="c1"># requested.</span>
    <span class="n">grpmax_expr</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">grpmax</span>
    <span class="n">grpmax_expr</span> <span class="o">=</span> <span class="n">grpmax_expr</span><span class="o">.</span><span class="n">gnomad</span><span class="o">.</span><span class="n">AF</span> <span class="k">if</span> <span class="s2">&quot;gnomad&quot;</span> <span class="ow">in</span> <span class="n">grpmax_expr</span> <span class="k">else</span> <span class="n">grpmax_expr</span><span class="o">.</span><span class="n">AF</span>
    <span class="n">filter_exprs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;all_variants&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span>
        <span class="o">**</span><span class="p">(</span><span class="n">get_capture_filter_exprs</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span> <span class="k">if</span> <span class="n">capture_regions</span> <span class="k">else</span> <span class="p">{}),</span>
        <span class="o">**</span><span class="n">get_summary_stats_variant_filter_expr</span><span class="p">(</span>
            <span class="n">ht</span><span class="p">,</span>
            <span class="n">filter_lcr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">filter_expr</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">filters</span><span class="p">,</span>
            <span class="n">freq_expr</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">,</span>
            <span class="n">grpmax_expr</span><span class="o">=</span><span class="n">grpmax_expr</span><span class="p">,</span>
            <span class="n">max_af</span><span class="o">=</span><span class="n">rare_variants_afs</span><span class="p">,</span>
            <span class="n">max_grpmax</span><span class="o">=</span><span class="n">rare_variants_grpmax</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="o">**</span><span class="n">csq_filter_expr</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Create the metadata for all requested filter groups.</span>
    <span class="n">ss_filters</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">SUM_STAT_FILTERS</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rare_variants_afs</span><span class="p">:</span>
        <span class="n">ss_filters</span><span class="p">[</span><span class="s2">&quot;max_af&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rare_variants_afs</span>
    <span class="k">if</span> <span class="n">rare_variants_grpmax</span><span class="p">:</span>
        <span class="n">ss_filters</span><span class="p">[</span><span class="s2">&quot;max_grpmax&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rare_variants_grpmax</span>

    <span class="c1"># If rare_variant_mode is True, then only include the rare variant filter groups</span>
    <span class="c1"># and variant_qc as the common filter groups.</span>
    <span class="n">common_filters</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">COMMON_FILTERS</span><span class="p">)</span>
    <span class="n">common_filter_combos</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">COMMON_FILTER_COMBOS</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rare_variant_mode</span><span class="p">:</span>
        <span class="n">common_filter_combos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rare_variant_max</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">rare_variants_afs</span><span class="p">:</span>
            <span class="n">rare_variant_max</span><span class="p">[</span><span class="s2">&quot;max_af&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rare_variants_afs</span><span class="p">)</span>
            <span class="n">common_filters</span><span class="p">[</span><span class="s2">&quot;max_af&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rare_variants_afs</span>
            <span class="n">common_filter_combos</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;variant_qc&quot;</span><span class="p">,</span> <span class="s2">&quot;max_af&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">rare_variants_grpmax</span><span class="p">:</span>
            <span class="n">rare_variant_max</span><span class="p">[</span><span class="s2">&quot;max_grpmax&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rare_variants_grpmax</span><span class="p">)</span>
            <span class="n">common_filters</span><span class="p">[</span><span class="s2">&quot;max_grpmax&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rare_variants_grpmax</span>
            <span class="n">common_filter_combos</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;variant_qc&quot;</span><span class="p">,</span> <span class="s2">&quot;max_grpmax&quot;</span><span class="p">])</span>

    <span class="n">filter_group_meta</span> <span class="o">=</span> <span class="n">get_summary_stats_filter_group_meta</span><span class="p">(</span>
        <span class="n">ss_filters</span><span class="p">,</span>
        <span class="n">common_filter_combos</span><span class="o">=</span><span class="n">common_filter_combos</span><span class="p">,</span>
        <span class="n">common_filter_override</span><span class="o">=</span><span class="n">common_filters</span><span class="p">,</span>
        <span class="n">lof_filter_combos</span><span class="o">=</span><span class="n">LOF_FILTER_COMBOS</span><span class="p">,</span>
        <span class="n">lof_filter_override</span><span class="o">=</span><span class="n">LOF_FILTERS_FOR_COMBO</span><span class="p">,</span>
        <span class="n">filter_key_rename</span><span class="o">=</span><span class="n">MAP_FILTER_FIELD_TO_META</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Create filter expressions for each filter group by combining the filter</span>
    <span class="c1"># expressions for each filter in the filter group metadata.</span>
    <span class="n">filter_groups_expr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">final_meta</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">filter_group</span> <span class="ow">in</span> <span class="n">filter_group_meta</span><span class="p">:</span>
        <span class="c1"># Initialize filter expression for the filter group with True to allow for</span>
        <span class="c1"># a filtering group that has no filters, e.g. all variants.</span>
        <span class="n">filter_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">filter_group_requested</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">filter_group</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Rename &quot;loftee_flags&quot; to &quot;loftee&quot; to match the filter expression keys.</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;loftee_flags&quot;</span><span class="p">,</span> <span class="s2">&quot;loftee&quot;</span><span class="p">)</span>
            <span class="c1"># Determine the correct key for filter_expr, it can be a combination of</span>
            <span class="c1"># the key and value, or just the key followed by using the value to get the</span>
            <span class="c1"># filter expression from a struct.</span>
            <span class="n">f_expr</span> <span class="o">=</span> <span class="n">filter_exprs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f_struct</span> <span class="o">=</span> <span class="n">filter_exprs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="c1"># If the filter group is in the combinations, but not filter_exprs, then</span>
            <span class="c1"># the filter group was not in the requested list.</span>
            <span class="k">if</span> <span class="n">f_expr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">f_struct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">filter_group_requested</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
            <span class="n">filter_expr</span> <span class="o">&amp;=</span> <span class="n">f_struct</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">if</span> <span class="n">f_expr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">f_expr</span>

        <span class="k">if</span> <span class="n">filter_group_requested</span><span class="p">:</span>
            <span class="n">filter_groups_expr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filter_expr</span><span class="p">)</span>
            <span class="n">final_meta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filter_group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Filter group </span><span class="si">%s</span><span class="s2"> was not requested and will not be included in the &quot;</span>
                <span class="s2">&quot;summary stats.&quot;</span><span class="p">,</span>
                <span class="n">filter_group</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="c1"># Remove &#39;no_lcr&#39; filter expression from filter groups and annotate the Table with</span>
    <span class="c1"># the no_lcr filter and an array of the filter groups.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="n">_no_lcr</span><span class="o">=</span><span class="n">filter_exprs</span><span class="p">[</span><span class="s2">&quot;no_lcr&quot;</span><span class="p">],</span>
        <span class="n">sex_chr_nonpar_group</span><span class="o">=</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">(),</span> <span class="s2">&quot;autosome_or_par&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">(),</span> <span class="s2">&quot;x_nonpar&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">(),</span> <span class="s2">&quot;y_nonpar&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">or_missing</span><span class="p">()</span>
        <span class="p">),</span>
        <span class="n">filter_groups</span><span class="o">=</span><span class="n">filter_groups_expr</span><span class="p">,</span>
        <span class="n">variant_ac</span><span class="o">=</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">),</span> <span class="n">ht</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">],</span>
        <span class="n">variant_af</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">,</span>
        <span class="n">variant_atypes</span><span class="o">=</span><span class="p">[</span><span class="n">_qc_allele_type</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">(</span><span class="n">filter_group_meta</span><span class="o">=</span><span class="n">final_meta</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Filter groups for summary stats: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">filter_group_meta</span><span class="p">)</span>

    <span class="c1"># Filter to only variants that are not in low confidence regions.</span>
    <span class="n">ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">_no_lcr</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;_no_lcr&quot;</span><span class="p">)</span>

    <span class="c1"># If rare_variant_mode is True, then filter to only the variants that have an AF</span>
    <span class="c1"># less than the maximum AF in the rare_variants_afs list or a grpmax less than the</span>
    <span class="c1"># maximum grpmax in the rare_variants_grpmax list. Variants with a missing AF or</span>
    <span class="c1"># grpmax will be also be kept to avoid filtering variants that are found in</span>
    <span class="c1"># non-grpmax genetic ancestry groups.</span>
    <span class="k">if</span> <span class="n">rare_variant_mode</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ht</span><span class="o">.</span><span class="n">filter_group_meta</span><span class="o">.</span><span class="n">index</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)})</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rare_variant_max</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">filter_groups</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span> <span class="n">idx</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="load_mt_for_sample_counts"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.load_mt_for_sample_counts">[docs]</a><span class="k">def</span> <span class="nf">load_mt_for_sample_counts</span><span class="p">(</span>
    <span class="n">data_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">filter_group_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">adjust_ploidy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load VDS variant data and prepare MatrixTable for computing per-sample stats counts.</span>

<span class="sd">    This function loads the VDS for the requested data type and prepares the variant</span>
<span class="sd">    data MatrixTable for computing per-sample stats counts. It does the following:</span>

<span class="sd">        - Filters to non-ref genotypes (likely unnecessary if the MT is already a</span>
<span class="sd">          variant data MT).</span>
<span class="sd">        - Annotates the rows with the filter group metadata from `filter_group_ht`.</span>
<span class="sd">        - Performs the high AB het -&gt; hom alt adjustment of GT, and adds a</span>
<span class="sd">          &#39;high_ab_het_ref&#39; annotation.</span>
<span class="sd">        - Filters to `adj` genotypes and selects only the necessary entries for</span>
<span class="sd">          downstream processing.</span>

<span class="sd">    :param data_type: Data type of the MatrixTable to return. Either &#39;genomes&#39; or</span>
<span class="sd">        &#39;exomes&#39;.</span>
<span class="sd">    :param filter_group_ht: Table containing filter group metadata from</span>
<span class="sd">        `get_summary_stats_filter_groups_ht`.</span>
<span class="sd">    :param adjust_ploidy: Whether to adjust ploidy. If `data_type` is &#39;exomes&#39;, ploidy</span>
<span class="sd">        is adjusted before determining the adj annotation. If `data_type` is &#39;genomes&#39;,</span>
<span class="sd">        the ploidy adjustment is done after determining the adj annotation. This</span>
<span class="sd">        difference is only added for consistency with v3.1, where we added the adj</span>
<span class="sd">        annotation before adjusting ploidy, but the correct thing to do is to adjust</span>
<span class="sd">        ploidy before determining the adj annotation. Default is False.</span>
<span class="sd">    :param kwargs: Additional keyword arguments to pass to the VDS loading function.</span>
<span class="sd">    :return: MatrixTable prepared for computing per-sample stats counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load the VDS for the requested data type and filter to the variants in the</span>
    <span class="c1"># filter group HT.</span>
    <span class="n">vds_load_func</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">get_gnomad_v4_vds</span> <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;exomes&quot;</span> <span class="k">else</span> <span class="n">get_gnomad_v4_genomes_vds</span>
    <span class="p">)</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">vds_load_func</span><span class="p">(</span>
        <span class="n">split</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">release_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">split_reference_blocks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">entries_to_keep</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;GT&quot;</span><span class="p">,</span> <span class="s2">&quot;GQ&quot;</span><span class="p">,</span> <span class="s2">&quot;DP&quot;</span><span class="p">,</span> <span class="s2">&quot;AD&quot;</span><span class="p">],</span>
        <span class="n">annotate_het_non_ref</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_variant_ht</span><span class="o">=</span><span class="n">filter_group_ht</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">variant_data</span>

    <span class="c1"># Annotate the MT with all annotations on the filter group HT.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">annotate_with_ht</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">filter_group_ht</span><span class="p">)</span>

    <span class="c1"># Filter to non-ref genotypes, which is likely unnecessary if the MT is already a</span>
    <span class="c1"># variant data MT.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_entries</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="o">.</span><span class="n">is_non_ref</span><span class="p">())</span>

    <span class="c1"># NOTE: The correct thing to do here is to adjust ploidy before determining the adj</span>
    <span class="c1"># annotation because haploid GTs have different adj filtering criteria, but the</span>
    <span class="c1"># option to adjust ploidy after adj is included for consistency with v3.1, where we</span>
    <span class="c1"># added the adj annotation before adjusting for sex ploidy.</span>
    <span class="n">gt_expr</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">GT</span>
    <span class="n">adj_expr</span> <span class="o">=</span> <span class="n">get_adj_expr</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">GQ</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">AD</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">adjust_ploidy</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Adjusting ploidy on sex chromosomes...&quot;</span><span class="p">)</span>
        <span class="n">gt_expr</span> <span class="o">=</span> <span class="n">adjusted_sex_ploidy_expr</span><span class="p">(</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span> <span class="n">gt_expr</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">meta</span><span class="o">.</span><span class="n">sex_imputation</span><span class="o">.</span><span class="n">sex_karyotype</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;exomes&quot;</span><span class="p">:</span>
            <span class="n">adj_expr</span> <span class="o">=</span> <span class="n">get_adj_expr</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">GQ</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">AD</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Performing high AB het -&gt; hom alt adjustment of GT...&quot;</span><span class="p">)</span>
    <span class="n">base_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">_het_non_ref</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">variant_af</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">AD</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">]</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_entries</span><span class="p">(</span>
        <span class="n">GT</span><span class="o">=</span><span class="n">hom_alt_depletion_fix</span><span class="p">(</span><span class="o">*</span><span class="n">base_args</span><span class="p">,</span> <span class="n">return_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">adj_expr</span><span class="p">,</span>
        <span class="n">high_ab_het_ref</span><span class="o">=</span><span class="n">hom_alt_depletion_fix</span><span class="p">(</span><span class="o">*</span><span class="n">base_args</span><span class="p">,</span> <span class="n">return_bool</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># Filter to adj genotypes and select only the necessary entries to be localized.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">filter_to_adj</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_entries</span><span class="p">(</span><span class="s2">&quot;GT&quot;</span><span class="p">,</span> <span class="s2">&quot;GQ&quot;</span><span class="p">,</span> <span class="s2">&quot;DP&quot;</span><span class="p">,</span> <span class="s2">&quot;high_ab_het_ref&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">select_cols</span><span class="p">()</span>

    <span class="c1"># Add the filter_group_meta global in filter_group_ht to the MT.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span>
        <span class="n">filter_group_meta</span><span class="o">=</span><span class="n">filter_group_ht</span><span class="o">.</span><span class="n">index_globals</span><span class="p">()</span><span class="o">.</span><span class="n">filter_group_meta</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">mt</span></div>


<div class="viewcode-block" id="annotate_per_sample_stat_combinations"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.annotate_per_sample_stat_combinations">[docs]</a><span class="k">def</span> <span class="nf">annotate_per_sample_stat_combinations</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">sums</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;n_indel&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;n_insertion&quot;</span><span class="p">,</span> <span class="s2">&quot;n_deletion&quot;</span><span class="p">],</span>
        <span class="s2">&quot;n_snp&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;n_transition&quot;</span><span class="p">,</span> <span class="s2">&quot;n_transversion&quot;</span><span class="p">],</span>
    <span class="p">},</span>
    <span class="n">diffs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">ratios</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;r_ti_tv&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;n_transition&quot;</span><span class="p">,</span> <span class="s2">&quot;n_transversion&quot;</span><span class="p">),</span>
        <span class="s2">&quot;r_ti_tv_singleton&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;n_singleton_ti&quot;</span><span class="p">,</span> <span class="s2">&quot;n_singleton_tv&quot;</span><span class="p">),</span>
        <span class="s2">&quot;r_het_hom_var&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;n_het&quot;</span><span class="p">,</span> <span class="s2">&quot;n_hom_var&quot;</span><span class="p">),</span>
        <span class="s2">&quot;r_insertion_deletion&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;n_insertion&quot;</span><span class="p">,</span> <span class="s2">&quot;n_deletion&quot;</span><span class="p">),</span>
    <span class="p">},</span>
    <span class="n">additional_stat_combos</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate the per-sample stats Table with ratios of other per-sample stats.</span>

<span class="sd">    :param ht: Input Table containing per-sample stats.</span>
<span class="sd">    :param sums: Dictionary of per-sample stats to sum. The key is the name of the sum</span>
<span class="sd">        and the value is a List of the stats to sum. Default is to sum the number of</span>
<span class="sd">        insertions and deletions to get the total number of indels, and the number of</span>
<span class="sd">        transitions and transversions to get the total number of transitions.</span>
<span class="sd">    :param diffs: Dictionary of per-sample stats to subtract. The key is the name of the</span>
<span class="sd">        difference and the value is a tuple of the stats to subtract, where the second</span>
<span class="sd">        stat is subtracted from the first. Default is {}.</span>
<span class="sd">    :param ratios: Dictionary of ratios to compute. The key is the name of the ratio</span>
<span class="sd">        and the value is a tuple of the numerator and denominator per-sample stats.</span>
<span class="sd">        Default is to compute the transition/transversion ratio, the singleton</span>
<span class="sd">        transition/transversion ratio, the heterozygous/homozygous variant ratio, and</span>
<span class="sd">        the insertion/deletion ratio.</span>
<span class="sd">    :param additional_stat_combos: Optional dictionary of additional per-sample stat</span>
<span class="sd">        combinations to compute. The key is the name of the stat and the value is a</span>
<span class="sd">        function that takes the per-sample stats struct and returns the computed stat.</span>
<span class="sd">        Default is {}.</span>
<span class="sd">    :return: Table containing per-sample stats annotated with the requested ratios.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">summary_stats</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">summary_stats</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">v</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sums</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
                <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">d1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">d2</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">diffs</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
                <span class="o">**</span><span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="n">divide_null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span> <span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ratios</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">},</span>
                <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">additional_stat_combos</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="create_per_sample_counts_ht"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.create_per_sample_counts_ht">[docs]</a><span class="k">def</span> <span class="nf">create_per_sample_counts_ht</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">gq_bins</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">60</span><span class="p">,),</span>
    <span class="n">dp_bins</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create Table of Hail&#39;s sample_qc output broken down by requested variant groupings.</span>

<span class="sd">    Useful for finding the number of variants per sample, either all variants, or</span>
<span class="sd">    variants fall into specific capture regions, or variants that are rare</span>
<span class="sd">    (adj AF &lt;0.1%), or variants categorized by predicted consequences in all, canonical</span>
<span class="sd">    or mane transcripts.</span>

<span class="sd">    :param mt: Input MatrixTable containing variant data. Must have multi-allelic sites</span>
<span class="sd">        split.</span>
<span class="sd">    :param gq_bins: Tuple of GQ bins to use for filtering. Default is (60,).</span>
<span class="sd">    :param dp_bins: Tuple of DP bins to use for filtering. Default is (20, 30).</span>
<span class="sd">    :return: Table containing per-sample variant counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">aggregate_cols</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">s</span><span class="p">))</span>
    <span class="c1"># Run Hail&#39;s &#39;vmt_sample_qc&#39; for all requested filter groups.</span>
    <span class="n">qc_expr</span> <span class="o">=</span> <span class="n">vmt_sample_qc</span><span class="p">(</span>
        <span class="n">global_gt</span><span class="o">=</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
        <span class="n">gq</span><span class="o">=</span><span class="n">mt</span><span class="o">.</span><span class="n">GQ</span><span class="p">,</span>
        <span class="n">variant_ac</span><span class="o">=</span><span class="n">mt</span><span class="o">.</span><span class="n">variant_ac</span><span class="p">,</span>
        <span class="n">variant_atypes</span><span class="o">=</span><span class="n">mt</span><span class="o">.</span><span class="n">variant_atypes</span><span class="p">,</span>
        <span class="n">dp</span><span class="o">=</span><span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span>
        <span class="n">gq_bins</span><span class="o">=</span><span class="n">gq_bins</span><span class="p">,</span>
        <span class="n">dp_bins</span><span class="o">=</span><span class="n">dp_bins</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Add aggregations for the number of hemizygous variants and high AB het ref</span>
    <span class="c1"># genotypes and rename the DP and GQ fields.</span>
    <span class="n">qc_expr</span> <span class="o">=</span> <span class="n">qc_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">n_hemi_var</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">count_where</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">()),</span>
        <span class="n">n_high_ab_het_ref</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">count_where</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">high_ab_het_ref</span><span class="p">),</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;n_over_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">qc_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;bases_over_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_threshold&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">bins</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;gq&quot;</span><span class="p">:</span> <span class="n">gq_bins</span><span class="p">,</span> <span class="s2">&quot;dp&quot;</span><span class="p">:</span> <span class="n">dp_bins</span><span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
        <span class="p">},</span>
    <span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;bases_over_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_threshold&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;gq&quot;</span><span class="p">,</span> <span class="s2">&quot;dp&quot;</span><span class="p">}])</span>

    <span class="c1"># Group the variants by &#39;sex_chr_nonpar_group&#39; (&#39;autosome_or_par&#39;, &#39;x_nonpar&#39;, and</span>
    <span class="c1"># &#39;y_nonpar&#39;) and aggregate the sample stats for each filter group. This gives a</span>
    <span class="c1"># dictionary where the keys are the &#39;sex_chr_nonpar_group&#39; and the values are the</span>
    <span class="c1"># array of sample stats for each filter group, which is then converted to an array</span>
    <span class="c1"># of key-value pairs.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_cols</span><span class="p">(</span>
        <span class="n">_ss</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">sex_chr_nonpar_group</span><span class="p">,</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">qc_expr</span><span class="p">),</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_groups</span><span class="p">),</span>
        <span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Explode the aggregated sample stats so that each &#39;sex_chr_nonpar_group&#39; has its</span>
    <span class="c1"># own row.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s2">&quot;_ss&quot;</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">transmute</span><span class="p">(</span><span class="n">sex_chr_nonpar_group</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">_ss</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">summary_stats</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">_ss</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;per_sample_stats&quot;</span><span class="p">,</span> <span class="s2">&quot;ht&quot;</span><span class="p">),</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Add &#39;n_indel&#39; and &#39; n_non_ref_alleles&#39; to the output Table.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">annotate_per_sample_stat_combinations</span><span class="p">(</span>
        <span class="n">ht</span><span class="p">,</span> <span class="n">diffs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;n_hom_var&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;n_hom_var&quot;</span><span class="p">,</span> <span class="s2">&quot;n_hemi_var&quot;</span><span class="p">)},</span> <span class="n">sums</span><span class="o">=</span><span class="p">{},</span> <span class="n">ratios</span><span class="o">=</span><span class="p">{}</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">annotate_per_sample_stat_combinations</span><span class="p">(</span>
        <span class="n">ht</span><span class="p">,</span>
        <span class="n">sums</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;n_indel&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;n_insertion&quot;</span><span class="p">,</span> <span class="s2">&quot;n_deletion&quot;</span><span class="p">],</span>
            <span class="s2">&quot;n_non_ref_alleles&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;n_non_ref&quot;</span><span class="p">,</span> <span class="s2">&quot;n_hom_var&quot;</span><span class="p">],</span>
        <span class="p">},</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;sex_chr_nonpar_group&quot;</span><span class="p">)</span>

    <span class="c1"># Fill missing key combinations with 0 or missing values.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">fill_missing_key_combinations</span><span class="p">(</span>
        <span class="n">ht</span><span class="p">,</span>
        <span class="p">{</span>
            <span class="s2">&quot;summary_stats&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">filter_group_meta</span><span class="p">)))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span>
                        <span class="n">f</span><span class="p">:</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;n_&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">summary_stats</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">element_type</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="n">samples</span><span class="p">},</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">(</span><span class="n">summary_stats_meta</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">filter_group_meta</span><span class="p">)</span></div>


<div class="viewcode-block" id="create_intermediate_mt_for_sample_counts"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.create_intermediate_mt_for_sample_counts">[docs]</a><span class="k">def</span> <span class="nf">create_intermediate_mt_for_sample_counts</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">gq_bins</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">60</span><span class="p">,),</span>
    <span class="n">dp_bins</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create intermediate MatrixTable for computing per-sample stats counts.</span>

<span class="sd">    This function creates an intermediate Table for use in</span>
<span class="sd">    `create_per_sample_counts_ht`. It does the following:</span>

<span class="sd">        - Converts the MT to a HT with a `sample_idx_by_stat` row annotation that is</span>
<span class="sd">          a struct of arrays of sample indices for each genotype level stat. The stats</span>
<span class="sd">          are: non_ref, het, hom_var, high_ab_het_ref, over_gq_{gq}, and over_dp_{dp}.</span>
<span class="sd">        - Changes the `filter_groups` annotation from an array of booleans to an array</span>
<span class="sd">          of structs where `group_filter` is the original filter group boolean value,</span>
<span class="sd">          mapping to the filter_group_meta, and adds boolean annotations to the struct</span>
<span class="sd">          indicating whether the variant is included in each of the following variant</span>
<span class="sd">          level stats: singleton, singleton_ti, singleton_tv, insertion, deletion,</span>
<span class="sd">          transition, and transversion.</span>

<span class="sd">    This structure creates a large intermediate Table that allows for memory efficient</span>
<span class="sd">    computation of per-sample stats counts. Smaller datasets do not require this</span>
<span class="sd">    intermediate step and can compute per-sample stats counts directly from the MT and</span>
<span class="sd">    with the use of Hail&#39;s `vmt_sample_qc` function.</span>

<span class="sd">    :param mt: Input MatrixTable containing variant data. Must have multi-allelic sites</span>
<span class="sd">        split.</span>
<span class="sd">    :param gq_bins: Tuple of GQ bins to use for filtering. Default is (60,).</span>
<span class="sd">    :param dp_bins: Tuple of DP bins to use for filtering. Default is (20, 30).</span>
<span class="sd">    :return: Intermediate Table for computing per-sample stats counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert MT to HT with a row annotation that is an array of all samples entries</span>
    <span class="c1"># for that variant.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">localize_entries</span><span class="p">(</span><span class="s2">&quot;_entries&quot;</span><span class="p">,</span> <span class="s2">&quot;_cols&quot;</span><span class="p">)</span>

    <span class="c1"># Add an index for each sample to the entries array to map entries back to samples.</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">GQ</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">high_ab_het_ref</span><span class="p">),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">_cols</span><span class="p">)),</span>
        <span class="n">ht</span><span class="o">.</span><span class="n">_entries</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Filter the entry array to genotype should be counted for each genotype level stat.</span>
    <span class="n">stat_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">non_ref</span><span class="o">=</span><span class="n">entry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">),</span>
        <span class="n">het</span><span class="o">=</span><span class="n">entry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_het</span><span class="p">()),</span>
        <span class="n">hom_var</span><span class="o">=</span><span class="n">entry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_hom_var</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">()),</span>
        <span class="n">hemi_var</span><span class="o">=</span><span class="n">entry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">()),</span>
        <span class="n">high_ab_het_ref</span><span class="o">=</span><span class="n">entry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span>
        <span class="o">**</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;over_gq_</span><span class="si">{</span><span class="n">gq</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">entry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">gq</span><span class="p">)</span> <span class="k">for</span> <span class="n">gq</span> <span class="ow">in</span> <span class="n">gq_bins</span><span class="p">},</span>
        <span class="o">**</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;over_dp_</span><span class="si">{</span><span class="n">dp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">entry</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">dp</span><span class="p">)</span> <span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="n">dp_bins</span><span class="p">},</span>
    <span class="p">)</span>

    <span class="c1"># Annotate the HT with the filter group metadata and the sample index by stat.</span>
    <span class="c1"># The filter groups annotation contains an array of structs with a group_filter</span>
    <span class="c1"># boolean indicating whether the variant belongs to the filter group and boolean</span>
    <span class="c1"># expressions for each variant level stat, i.e. singleton, indicating whether the</span>
    <span class="c1"># variant should be counted for that stat.</span>
    <span class="c1"># The sample_idx_by_stat annotation contains a struct with arrays of sample indices</span>
    <span class="c1"># for each genotype level stat.</span>
    <span class="n">ac1</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">variant_ac</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">allele_type_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">ht</span><span class="o">.</span><span class="n">variant_atypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ALLELE_TYPE_MAP</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="s2">&quot;sex_chr_nonpar_group&quot;</span><span class="p">,</span>
        <span class="n">filter_groups</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">filter_groups</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                <span class="n">group_filter</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
                <span class="n">singleton</span><span class="o">=</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">ac1</span><span class="p">,</span>
                <span class="n">singleton_ti</span><span class="o">=</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">allele_type_expr</span><span class="o">.</span><span class="n">transition</span> <span class="o">&amp;</span> <span class="n">ac1</span><span class="p">,</span>
                <span class="n">singleton_tv</span><span class="o">=</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">allele_type_expr</span><span class="o">.</span><span class="n">transversion</span> <span class="o">&amp;</span> <span class="n">ac1</span><span class="p">,</span>
                <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">allele_type_expr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ALLELE_TYPE_MAP</span><span class="o">.</span><span class="n">keys</span><span class="p">()},</span>
            <span class="p">)</span>
        <span class="p">),</span>
        <span class="n">sample_idx_by_stat</span><span class="o">=</span><span class="n">stat_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">stat_expr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">stat_expr</span><span class="p">}</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># Annotate the HT with globals for the sample IDs and filter group metadata.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">(</span>
        <span class="n">samples</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">_cols</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">s</span><span class="p">),</span>
        <span class="n">filter_group_meta</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">filter_group_meta</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="create_per_sample_counts_from_intermediate_ht"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.create_per_sample_counts_from_intermediate_ht">[docs]</a><span class="k">def</span> <span class="nf">create_per_sample_counts_from_intermediate_ht</span><span class="p">(</span><span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create Table of sample QC metrics broken down by requested variant groupings.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This function is memory intensive and should be run on a cluster with</span>
<span class="sd">        n1-highmem-8 workers. It also requires shuffling, so a cluster with all</span>
<span class="sd">        workers is recommended.</span>

<span class="sd">    Takes an intermediate Table (returned by `create_intermediate_mt_for_sample_counts`)</span>
<span class="sd">    with an array of variant level stats by filter groups and an array of sample</span>
<span class="sd">    indices for each genotype level stat.</span>

<span class="sd">    This function restructures the Table a few times to get around memory errors that</span>
<span class="sd">    occur when trying to aggregate the Table directly.</span>

<span class="sd">    The following steps are taken:</span>

<span class="sd">        - The Table is grouped by filter group (including all variant level stats) and</span>
<span class="sd">          aggregated to get the count of variants for each sample in each filter group.</span>
<span class="sd">          Leads to a Table where the number of rows is approximately the number of</span>
<span class="sd">          filter groups times the possible permutations of variant level stats.</span>

<span class="sd">            - Since this number can sometimes be too few partitions to get around the</span>
<span class="sd">              memory errors, we approximate a reasonable number of partitions as the</span>
<span class="sd">              number required to split the table into approximately 10,000 variants per</span>
<span class="sd">              partition.</span>
<span class="sd">            - Then we artificially increase the number of aggregation groups by</span>
<span class="sd">              assigning a random group number to each variant, so that when the Table</span>
<span class="sd">              is grouped by both the filter group and the random group instead</span>
<span class="sd">              of only the filter group, the number of rows will be approximately the</span>
<span class="sd">              number of desired partitions.</span>
<span class="sd">            - Therefore, the number of random groups is the ideal number of partitions</span>
<span class="sd">              divided by the number of possible filter groups.</span>

<span class="sd">        - Sample IDs are mapped to the sample indices and the Table is exploded so that</span>
<span class="sd">          each row is counts for a sample and a filter group. The number of rows in the</span>
<span class="sd">          Table is approximately the number of samples times the number of rows in the</span>
<span class="sd">          previous Table.</span>
<span class="sd">        - Group the Table by sample to get a struct of the count of variants by sample</span>
<span class="sd">          QC metric for each sample in each filter group.</span>
<span class="sd">        - Add sample QC stats that are combinations of other stats.</span>

<span class="sd">    :param ht: Input Table containing variant data. Must have multi-allelic sites split.</span>
<span class="sd">    :return: Table containing per-sample variant counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the number of filter groups, samples, and variants in the Table to determine</span>
    <span class="c1"># a reasonable number of partitions to use for the aggregated filter group HT, and</span>
    <span class="c1"># the number of random groups needed to have approximately the desired partitions.</span>
    <span class="n">n_filter_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">filter_group_meta</span><span class="p">))</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">samples</span><span class="p">))</span>
    <span class="n">n_variants</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
    <span class="c1"># 2^3 = 8 because there are about 3 variant level stats: singletons (singleton_ti</span>
    <span class="c1"># and singleton_tv will never overlap, and one of them will always also be a</span>
    <span class="c1"># singleton), transition/transversion, insertion/deletion.</span>
    <span class="n">n_filter_permutations</span> <span class="o">=</span> <span class="n">n_filter_groups</span> <span class="o">*</span> <span class="mi">8</span>
    <span class="c1"># Split the Table into approximately 10,000 variants per partition.</span>
    <span class="n">n_mem_partitions</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_variants</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">),</span> <span class="n">n_filter_permutations</span><span class="p">)</span>
    <span class="c1"># Compute the number of random groups needed to have approximately n_mem_partitions.</span>
    <span class="n">n_rand_groups</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_mem_partitions</span> <span class="o">/</span> <span class="n">n_filter_permutations</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Aggregating counts for each sample in each filter group...</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Number of samples: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Number of variants: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Number of filter groups: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Approximate number of filter permutations: </span><span class="si">%d</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Calculated number of partitions to improve memory usage: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Number of random groups to have approximately the above partitions: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">n_samples</span><span class="p">,</span>
        <span class="n">n_variants</span><span class="p">,</span>
        <span class="n">n_filter_groups</span><span class="p">,</span>
        <span class="n">n_filter_permutations</span><span class="p">,</span>
        <span class="n">n_mem_partitions</span><span class="p">,</span>
        <span class="n">n_rand_groups</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Group by filter groups and the random group to get the count of variants matching</span>
    <span class="c1"># the filter group and random group for each sample.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">_rand_group</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">rand_int32</span><span class="p">(</span><span class="n">n_rand_groups</span><span class="p">))</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="s2">&quot;sex_chr_nonpar_group&quot;</span><span class="p">,</span> <span class="s2">&quot;filter_groups&quot;</span><span class="p">,</span> <span class="s2">&quot;_rand_group&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="n">counts</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">sample_idx_by_stat</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">tmp_path</span> <span class="o">=</span> <span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;agg_filter_groups&quot;</span><span class="p">,</span> <span class="s2">&quot;ht&quot;</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">,</span> <span class="n">_n_partitions</span><span class="o">=</span><span class="n">n_mem_partitions</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reading in as </span><span class="si">%s</span><span class="s2"> partitions.&quot;</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">n_partitions</span><span class="p">())</span>

    <span class="c1"># Map the sample indices to the sample IDs and fill in samples with no counts for</span>
    <span class="c1"># the variant level stat with 0, then explode the stat counts array. This</span>
    <span class="c1"># transforms the Table so there is one row for each sample and filter group. Since</span>
    <span class="c1"># we need aggregate counts for each sample by filter group, and the number of</span>
    <span class="c1"># samples is much larger than the number of filter groups, this allows for</span>
    <span class="c1"># repartitioning the Table to have more partitions than the number of filter groups,</span>
    <span class="c1"># helping the final aggregation get around memory errors.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ht</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="s2">&quot;sex_chr_nonpar_group&quot;</span><span class="p">,</span> <span class="s2">&quot;filter_groups&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="n">counts</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span>
                <span class="n">ht</span><span class="o">.</span><span class="n">samples</span><span class="p">,</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                        <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                    <span class="p">),</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">),</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s2">&quot;counts&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">counts</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># After the explode, the number of rows is much larger, at approximately the number</span>
    <span class="c1"># of samples times the number of filter groups, so it&#39;s important to repartition the</span>
    <span class="c1"># Table. In this case, we try to have about 50,000 rows per partition, which seems</span>
    <span class="c1"># to work well, but only going as low as 50 partitions. The repartition is done as a</span>
    <span class="c1"># repartition on read, and the key_by is needed because otherwise the</span>
    <span class="c1"># repartitioning will not work, and will only be as many partitions as the number</span>
    <span class="c1"># of filter_groups.</span>
    <span class="n">n_partitions</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">n_filter_permutations</span> <span class="o">*</span> <span class="n">n_samples</span><span class="p">)</span> <span class="o">/</span> <span class="mi">50000</span><span class="p">),</span> <span class="mi">50</span><span class="p">)</span>
    <span class="n">tmp_path</span> <span class="o">=</span> <span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;stat_counts_explode_sample&quot;</span><span class="p">,</span> <span class="s2">&quot;ht&quot;</span><span class="p">)</span>
    <span class="n">ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">tmp_path</span><span class="p">,</span> <span class="n">_n_partitions</span><span class="o">=</span><span class="n">n_partitions</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reading in as </span><span class="si">%s</span><span class="s2"> partitions.&quot;</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">n_partitions</span><span class="p">())</span>

    <span class="c1"># Group by sample to get a struct of the count of variants for each sample QC stat</span>
    <span class="c1"># for each sample in each filter group. Uses &#39;filter_groups&#39; annotation to filter to</span>
    <span class="c1"># variants that belong to each filter group, and the &#39;counts&#39; annotation to get</span>
    <span class="c1"># the count of variants for each genotype level stat. The &#39;non_ref_alleles&#39; genotype</span>
    <span class="c1"># level count is used with all variant level stat filter to get the count of</span>
    <span class="c1"># variants for each.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">counts</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">non_ref_alleles</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">non_ref</span> <span class="o">+</span> <span class="n">ht</span><span class="o">.</span><span class="n">counts</span><span class="o">.</span><span class="n">hom_var</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">variant_filters</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">filter_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s2">&quot;group_filter&quot;</span><span class="p">]</span>
    <span class="n">agg_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="o">*</span> <span class="n">ht</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ht</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;sex_chr_nonpar_group&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="n">summary_stats</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;n_</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">agg_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;group_filter&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">counts</span><span class="p">},</span>
                    <span class="o">**</span><span class="p">{</span>
                        <span class="sa">f</span><span class="s2">&quot;n_</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">agg_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="s2">&quot;non_ref_alleles&quot;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">variant_filters</span>
                    <span class="p">},</span>
                <span class="p">),</span>
                <span class="n">ht</span><span class="o">.</span><span class="n">filter_groups</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;per_sample_counts&quot;</span><span class="p">,</span> <span class="s2">&quot;ht&quot;</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="c1"># Add &#39;n_indel&#39;, &#39;n_snp&#39; and sample QC stats that are combinations of other stats.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">annotate_per_sample_stat_combinations</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span>

    <span class="n">n_partitions</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">*</span> <span class="mf">0.001</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Naive coalescing to </span><span class="si">%s</span><span class="s2"> partitions.&quot;</span><span class="p">,</span> <span class="n">n_partitions</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">naive_coalesce</span><span class="p">(</span><span class="n">n_partitions</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">(</span><span class="n">summary_stats_meta</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">filter_group_meta</span><span class="p">)</span></div>


<div class="viewcode-block" id="combine_autosome_and_sex_chr_stats"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.combine_autosome_and_sex_chr_stats">[docs]</a><span class="k">def</span> <span class="nf">combine_autosome_and_sex_chr_stats</span><span class="p">(</span>
    <span class="n">autosome_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">sex_chr_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine autosomal and sex chromosome per-sample stats Tables.</span>

<span class="sd">    :param autosome_ht: Table containing per-sample stats for autosomes.</span>
<span class="sd">    :param sex_chr_ht: Table containing per-sample stats for sex chromosomes.</span>
<span class="sd">    :return: Table containing combined per-sample stats.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">autosome_ht</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">sex_chr_ht</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;sex_chr_nonpar_group&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="n">summary_stats</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;n_&quot;</span><span class="p">)</span>
                <span class="p">},</span>
            <span class="p">),</span>
            <span class="n">ht</span><span class="o">.</span><span class="n">summary_stats</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">annotate_per_sample_stat_combinations</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">sums</span><span class="o">=</span><span class="p">{})</span></div>


<div class="viewcode-block" id="compute_agg_sample_stats"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.compute_agg_sample_stats">[docs]</a><span class="k">def</span> <span class="nf">compute_agg_sample_stats</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">meta_ht</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">by_ancestry</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">by_subset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute aggregate statistics for per-sample QC metrics.</span>

<span class="sd">    :param ht: Table containing sample QC metrics.</span>
<span class="sd">    :param meta_ht: Optional Table containing sample metadata. Required if</span>
<span class="sd">        `by_ancestry` is True.</span>
<span class="sd">    :param by_ancestry: Boolean indicating whether to stratify by ancestry.</span>
<span class="sd">    :param by_subset: Boolean indicating whether to stratify by subset. This is only</span>
<span class="sd">         working on &quot;exomes&quot; data.</span>
<span class="sd">    :return: Struct of aggregate statistics for per-sample QC metrics.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">meta_ht</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">by_ancestry</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If `by_ancestry` is True, `meta_ht` is required.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">meta_ht</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">by_subset</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If `by_subset` is True, `meta_ht` is required.&quot;</span><span class="p">)</span>

    <span class="n">subset</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gnomad&quot;</span><span class="p">]</span>
    <span class="n">gen_anc</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;global&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">meta_ht</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">meta_s</span> <span class="o">=</span> <span class="n">meta_ht</span><span class="p">[</span><span class="n">ht</span><span class="o">.</span><span class="n">s</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">by_subset</span><span class="p">:</span>
            <span class="n">subset_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">meta_s</span><span class="o">.</span><span class="n">project_meta</span><span class="o">.</span><span class="n">ukb_sample</span><span class="p">,</span> <span class="s2">&quot;ukb&quot;</span><span class="p">,</span> <span class="s2">&quot;non-ukb&quot;</span><span class="p">)</span>
            <span class="n">subset</span> <span class="o">+=</span> <span class="p">[</span><span class="n">subset_expr</span><span class="p">]</span> <span class="k">if</span> <span class="n">by_subset</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">gen_anc</span> <span class="o">+=</span> <span class="p">[</span><span class="n">meta_s</span><span class="o">.</span><span class="n">population_inference</span><span class="o">.</span><span class="n">pop</span><span class="p">]</span> <span class="k">if</span> <span class="n">by_ancestry</span> <span class="k">else</span> <span class="p">[]</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">subset</span><span class="o">=</span><span class="n">subset</span><span class="p">,</span>
            <span class="n">gen_anc</span><span class="o">=</span><span class="n">gen_anc</span><span class="p">,</span>
            <span class="n">summary_stats</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">summary_stats_meta</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">summary_stats</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">select_globals</span><span class="p">()</span>
        <span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s2">&quot;gen_anc&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s2">&quot;subset&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s2">&quot;summary_stats&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">filter_group_meta</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">summary_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">summary_stats</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">summary_stats</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;agg_sample_stats.explode&quot;</span><span class="p">,</span> <span class="s2">&quot;ht&quot;</span><span class="p">))</span>

    <span class="c1"># Note: For this aggregation to work on the full dataset without a Spark/Hadoop</span>
    <span class="c1"># error, it needs to be split into multiple aggregations. An easy split is to move</span>
    <span class="c1"># the quantiles aggregation into a separate aggregation, which will allow the</span>
    <span class="c1"># aggregation to work on the full dataset.</span>
    <span class="n">grouped_ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span>
        <span class="s2">&quot;subset&quot;</span><span class="p">,</span> <span class="s2">&quot;gen_anc&quot;</span><span class="p">,</span> <span class="s2">&quot;sex_chr_nonpar_group&quot;</span><span class="p">,</span> <span class="s2">&quot;filter_group_meta&quot;</span>
    <span class="p">)</span>
    <span class="n">ht1</span> <span class="o">=</span> <span class="n">grouped_ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="nb">max</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">summary_stats</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">)</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;agg_sample_stats.first_agg&quot;</span><span class="p">,</span> <span class="s2">&quot;ht&quot;</span><span class="p">))</span>
    <span class="n">ht2</span> <span class="o">=</span> <span class="n">grouped_ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">approx_quantiles</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">summary_stats</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">)</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;agg_sample_stats.second_agg&quot;</span><span class="p">,</span> <span class="s2">&quot;ht&quot;</span><span class="p">))</span>
    <span class="n">ht2_keyed</span> <span class="o">=</span> <span class="n">ht2</span><span class="p">[</span><span class="n">ht1</span><span class="o">.</span><span class="n">key</span><span class="p">]</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht1</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">ht1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">quantiles</span><span class="o">=</span><span class="n">ht2_keyed</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ht1</span><span class="o">.</span><span class="n">row_value</span><span class="p">}</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="get_pipeline_resources"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.get_pipeline_resources">[docs]</a><span class="k">def</span> <span class="nf">get_pipeline_resources</span><span class="p">(</span>
    <span class="n">data_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">test</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">test_gene</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">autosomes_only</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">sex_chr_only</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">use_intermediate_mt_for_sample_counts</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">by_ancestry</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">by_subset</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">custom_suffix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PipelineResourceCollection</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get PipelineResourceCollection for all resources needed in the per-sample stats pipeline.</span>

<span class="sd">    :param data_type: Data type of the dataset.</span>
<span class="sd">    :param test: Whether to gather all resources for testing.</span>
<span class="sd">    :param test_gene: Whether the test is being performed on specific gene(s).</span>
<span class="sd">    :param autosomes_only: Whether to gather resources for autosomes only.</span>
<span class="sd">    :param sex_chr_only: Whether to gather resources for sex chromosomes only.</span>
<span class="sd">    :param use_intermediate_mt_for_sample_counts: Whether to use an intermediate MT for</span>
<span class="sd">        computing per-sample counts.</span>
<span class="sd">    :param by_ancestry: Whether to return resource for aggregate stats stratified by</span>
<span class="sd">        ancestry.</span>
<span class="sd">    :param by_subset: Whether to return resource for aggregate stats stratified by</span>
<span class="sd">        subset.</span>
<span class="sd">    :param overwrite: Whether to overwrite resources if they exist.</span>
<span class="sd">    :param custom_suffix: Optional custom suffix to add to the resource names.</span>
<span class="sd">    :return: PipelineResourceCollection containing resources for all steps of the</span>
<span class="sd">        per-sample stats pipeline.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize pipeline resource collection.</span>
    <span class="n">per_sample_pipeline</span> <span class="o">=</span> <span class="n">PipelineResourceCollection</span><span class="p">(</span>
        <span class="n">pipeline_name</span><span class="o">=</span><span class="s2">&quot;calculate_per_sample_stats&quot;</span><span class="p">,</span>
        <span class="n">pipeline_resources</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;sample_qc/create_sample_qc_metadata_ht.py&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;meta_ht&quot;</span><span class="p">:</span> <span class="n">meta</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">res_base_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;test&quot;</span><span class="p">:</span> <span class="n">test</span><span class="p">,</span> <span class="s2">&quot;data_type&quot;</span><span class="p">:</span> <span class="n">data_type</span><span class="p">,</span> <span class="s2">&quot;suffix&quot;</span><span class="p">:</span> <span class="n">custom_suffix</span><span class="p">}</span>

    <span class="c1"># Create resource collection for each step of the pipeline.</span>
    <span class="n">create_filter_group</span> <span class="o">=</span> <span class="n">PipelineStepResourceCollection</span><span class="p">(</span>
        <span class="s2">&quot;--create-filter-group-ht&quot;</span><span class="p">,</span>
        <span class="n">input_resources</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;v4 release HT&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;release_ht&quot;</span><span class="p">:</span> <span class="n">release_sites</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="n">data_type</span><span class="p">)}</span>
        <span class="p">},</span>
        <span class="n">output_resources</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;filter_groups_ht&quot;</span><span class="p">:</span> <span class="n">get_summary_stats_filtering_groups</span><span class="p">(</span><span class="o">**</span><span class="n">res_base_args</span><span class="p">)</span>
        <span class="p">},</span>
    <span class="p">)</span>

    <span class="c1"># Uses `test_gene` instead of just `test` because the filter groups HT will not</span>
    <span class="c1"># have the same partitions as the raw VDS, so unless the test is on a specific</span>
    <span class="c1"># gene(s), the test will not work as expected.</span>
    <span class="n">filter_groups_ht</span> <span class="o">=</span> <span class="n">get_summary_stats_filtering_groups</span><span class="p">(</span>
        <span class="n">data_type</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">test_gene</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">custom_suffix</span>
    <span class="p">)</span>
    <span class="n">create_intermediate</span> <span class="o">=</span> <span class="n">PipelineStepResourceCollection</span><span class="p">(</span>
        <span class="s2">&quot;--create-intermediate-mt-for-sample-counts&quot;</span><span class="p">,</span>
        <span class="n">input_resources</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;--create-filter-group-ht&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;filter_groups_ht&quot;</span><span class="p">:</span> <span class="n">filter_groups_ht</span><span class="p">}</span>
        <span class="p">},</span>
        <span class="n">output_resources</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;temp_intermediate_ht&quot;</span><span class="p">:</span> <span class="n">TableResource</span><span class="p">(</span>
                <span class="n">get_checkpoint_path</span><span class="p">(</span>
                    <span class="s2">&quot;per_sample_summary_stats_intermediate&quot;</span>
                    <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;.test&quot;</span> <span class="k">if</span> <span class="n">test</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;.autosomes&quot;</span> <span class="k">if</span> <span class="n">autosomes_only</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;.sex_chr&quot;</span> <span class="k">if</span> <span class="n">sex_chr_only</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">},</span>
    <span class="p">)</span>
    <span class="n">create_per_sample_counts</span> <span class="o">=</span> <span class="n">PipelineStepResourceCollection</span><span class="p">(</span>
        <span class="s2">&quot;--create-per-sample-counts-ht&quot;</span><span class="p">,</span>
        <span class="n">pipeline_input_steps</span><span class="o">=</span><span class="p">(</span>
            <span class="p">[</span><span class="n">create_intermediate</span><span class="p">]</span> <span class="k">if</span> <span class="n">use_intermediate_mt_for_sample_counts</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="p">),</span>
        <span class="n">add_input_resources</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;--create-filter-group-ht&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;filter_groups_ht&quot;</span><span class="p">:</span> <span class="n">filter_groups_ht</span><span class="p">}</span>
        <span class="p">},</span>
        <span class="n">output_resources</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;per_sample_ht&quot;</span><span class="p">:</span> <span class="n">get_per_sample_counts</span><span class="p">(</span>
                <span class="o">**</span><span class="n">res_base_args</span><span class="p">,</span>
                <span class="n">autosomes</span><span class="o">=</span><span class="n">autosomes_only</span><span class="p">,</span>
                <span class="n">sex_chr</span><span class="o">=</span><span class="n">sex_chr_only</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">},</span>
    <span class="p">)</span>
    <span class="n">combine_stats</span> <span class="o">=</span> <span class="n">PipelineStepResourceCollection</span><span class="p">(</span>
        <span class="s2">&quot;--combine-autosome-and-sex-chr-stats&quot;</span><span class="p">,</span>
        <span class="n">input_resources</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;--create-per-sample-counts-ht --autosomes-only-stats&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;autosomes_ht&quot;</span><span class="p">:</span> <span class="n">get_per_sample_counts</span><span class="p">(</span><span class="o">**</span><span class="n">res_base_args</span><span class="p">,</span> <span class="n">autosomes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="s2">&quot;--create-per-sample-counts-ht --sex-chr-only-stats&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;sex_chr_ht&quot;</span><span class="p">:</span> <span class="n">get_per_sample_counts</span><span class="p">(</span><span class="o">**</span><span class="n">res_base_args</span><span class="p">,</span> <span class="n">sex_chr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">},</span>
        <span class="p">},</span>
        <span class="n">output_resources</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;per_sample_ht&quot;</span><span class="p">:</span> <span class="n">get_per_sample_counts</span><span class="p">(</span><span class="o">**</span><span class="n">res_base_args</span><span class="p">)},</span>
    <span class="p">)</span>
    <span class="n">aggregate_stats</span> <span class="o">=</span> <span class="n">PipelineStepResourceCollection</span><span class="p">(</span>
        <span class="s2">&quot;--aggregate-sample-stats&quot;</span><span class="p">,</span>
        <span class="n">pipeline_input_steps</span><span class="o">=</span><span class="p">[</span><span class="n">create_per_sample_counts</span><span class="p">],</span>
        <span class="n">output_resources</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;per_sample_agg_ht&quot;</span><span class="p">:</span> <span class="n">get_per_sample_counts</span><span class="p">(</span>
                <span class="o">**</span><span class="n">res_base_args</span><span class="p">,</span>
                <span class="n">autosomes</span><span class="o">=</span><span class="n">autosomes_only</span><span class="p">,</span>
                <span class="n">sex_chr</span><span class="o">=</span><span class="n">sex_chr_only</span><span class="p">,</span>
                <span class="n">aggregated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">by_ancestry</span><span class="o">=</span><span class="n">by_ancestry</span><span class="p">,</span>
                <span class="n">by_subset</span><span class="o">=</span><span class="n">by_subset</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">},</span>
    <span class="p">)</span>
    <span class="c1"># Add all steps to the pipeline resource collection.</span>
    <span class="n">per_sample_pipeline</span><span class="o">.</span><span class="n">add_steps</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;create_filter_group&quot;</span><span class="p">:</span> <span class="n">create_filter_group</span><span class="p">,</span>
            <span class="s2">&quot;create_intermediate&quot;</span><span class="p">:</span> <span class="n">create_intermediate</span><span class="p">,</span>
            <span class="s2">&quot;create_per_sample_counts&quot;</span><span class="p">:</span> <span class="n">create_per_sample_counts</span><span class="p">,</span>
            <span class="s2">&quot;combine_stats&quot;</span><span class="p">:</span> <span class="n">combine_stats</span><span class="p">,</span>
            <span class="s2">&quot;aggregate_stats&quot;</span><span class="p">:</span> <span class="n">aggregate_stats</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">per_sample_pipeline</span></div>


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../../../../api_reference/v4/assessment/calculate_per_sample_stats.html#gnomad_qc.v4.assessment.calculate_per_sample_stats.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collect per-sample variant counts and aggregate sample statistics.&quot;&quot;&quot;</span>
    <span class="n">hl</span><span class="o">.</span><span class="n">init</span><span class="p">(</span>
        <span class="n">log</span><span class="o">=</span><span class="s2">&quot;/per_sample_stats&quot;</span><span class="p">,</span>
        <span class="n">default_reference</span><span class="o">=</span><span class="s2">&quot;GRCh38&quot;</span><span class="p">,</span>
        <span class="n">tmp_dir</span><span class="o">=</span><span class="s2">&quot;gs://gnomad-tmp-30day&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># SSA Logs are easier to troubleshoot with.</span>
    <span class="n">hl</span><span class="o">.</span><span class="n">_set_flags</span><span class="p">(</span><span class="n">use_ssa_logs</span><span class="o">=</span><span class="s2">&quot;1&quot;</span><span class="p">)</span>

    <span class="n">overwrite</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">overwrite</span>
    <span class="n">data_type</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">data_type</span>
    <span class="n">create_filter_group</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">create_filter_group_ht</span>
    <span class="n">create_per_sample_counts</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">create_per_sample_counts_ht</span>
    <span class="n">create_intermediate</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">create_intermediate_mt_for_sample_counts</span>
    <span class="n">use_intermediate</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">use_intermediate_mt_for_sample_counts</span>
    <span class="n">combine_chr_stats</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">combine_autosome_and_sex_chr_stats</span>
    <span class="n">aggregate_stats</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">aggregate_sample_stats</span>
    <span class="n">autosomes_only</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">autosomes_only_stats</span>
    <span class="n">sex_chr_only</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">sex_chr_only_stats</span>
    <span class="n">exomes</span> <span class="o">=</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;exomes&quot;</span>
    <span class="n">rare_variants_afs</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">rare_variants_afs</span>
    <span class="n">rare_variants_grpmax</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">rare_variants_grpmax</span>
    <span class="n">run_rare_variant_mode</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">run_rare_variant_mode</span>
    <span class="n">custom_suffix</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">custom_suffix</span>
    <span class="k">if</span> <span class="n">custom_suffix</span> <span class="ow">or</span> <span class="n">run_rare_variant_mode</span><span class="p">:</span>
        <span class="n">custom_suffix</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;rare_variants&quot;</span> <span class="k">if</span> <span class="n">run_rare_variant_mode</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;.</span><span class="si">{</span><span class="n">custom_suffix</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">custom_suffix</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">run_rare_variant_mode</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="n">create_per_sample_counts</span> <span class="ow">or</span> <span class="n">combine_chr_stats</span> <span class="ow">or</span> <span class="n">aggregate_stats</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Running rare variant mode with create_per_sample_counts, &quot;</span>
            <span class="s2">&quot;combine_chr_stats, or aggregate_stats is not implemented yet.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">autosomes_only</span> <span class="ow">and</span> <span class="n">sex_chr_only</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot use --autosomes-only-stats and --sex-chr-only-stats at the same &quot;</span>
            <span class="s2">&quot;time.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exomes</span> <span class="ow">and</span> <span class="n">args</span><span class="o">.</span><span class="n">by_subset</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Stratifying by subset is only working on exomes data type.&quot;</span><span class="p">)</span>

    <span class="c1"># Handle test arguments.</span>
    <span class="n">test_dataset</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">test_dataset</span>
    <span class="n">test_gene</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">test_gene</span>
    <span class="n">test_difficult_partitions</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">test_difficult_partitions</span>
    <span class="n">test_partitions</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">test_n_partitions</span><span class="p">))</span> <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">test_n_partitions</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="p">)</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">test_partitions</span> <span class="ow">or</span> <span class="n">test_dataset</span> <span class="ow">or</span> <span class="n">test_gene</span>
    <span class="n">filter_intervals</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
        <span class="n">filter_intervals</span><span class="p">,</span> <span class="n">test_partitions</span> <span class="o">=</span> <span class="n">process_test_args</span><span class="p">(</span>
            <span class="n">data_type</span><span class="p">,</span>
            <span class="n">test_dataset</span><span class="o">=</span><span class="n">test_dataset</span><span class="p">,</span>
            <span class="n">test_gene</span><span class="o">=</span><span class="n">test_gene</span><span class="p">,</span>
            <span class="n">test_partitions</span><span class="o">=</span><span class="n">test_partitions</span><span class="p">,</span>
            <span class="n">test_difficult_partitions</span><span class="o">=</span><span class="n">test_difficult_partitions</span><span class="p">,</span>
            <span class="n">create_filter_group</span><span class="o">=</span><span class="n">create_filter_group</span><span class="p">,</span>
            <span class="n">create_intermediate</span><span class="o">=</span><span class="n">create_intermediate</span><span class="p">,</span>
            <span class="n">create_per_sample_counts</span><span class="o">=</span><span class="n">create_per_sample_counts</span><span class="p">,</span>
            <span class="n">use_intermediate</span><span class="o">=</span><span class="n">use_intermediate</span><span class="p">,</span>
            <span class="n">sex_chr_only</span><span class="o">=</span><span class="n">sex_chr_only</span><span class="p">,</span>
            <span class="n">autosomes_only</span><span class="o">=</span><span class="n">autosomes_only</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Get per-sample stats pipeline resources.</span>
    <span class="n">per_sample_stats_resources</span> <span class="o">=</span> <span class="n">get_pipeline_resources</span><span class="p">(</span>
        <span class="n">data_type</span><span class="p">,</span>
        <span class="n">test</span><span class="o">=</span><span class="n">test</span><span class="p">,</span>
        <span class="n">test_gene</span><span class="o">=</span><span class="n">test_gene</span><span class="p">,</span>
        <span class="n">autosomes_only</span><span class="o">=</span><span class="n">autosomes_only</span><span class="p">,</span>
        <span class="n">sex_chr_only</span><span class="o">=</span><span class="n">sex_chr_only</span><span class="p">,</span>
        <span class="n">use_intermediate_mt_for_sample_counts</span><span class="o">=</span><span class="n">use_intermediate</span><span class="p">,</span>
        <span class="n">by_ancestry</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">by_ancestry</span><span class="p">,</span>
        <span class="n">by_subset</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">by_subset</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
        <span class="n">custom_suffix</span><span class="o">=</span><span class="n">custom_suffix</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">meta_ht</span> <span class="o">=</span> <span class="n">per_sample_stats_resources</span><span class="o">.</span><span class="n">meta_ht</span><span class="o">.</span><span class="n">ht</span><span class="p">()</span>

    <span class="c1"># Define VDS load function and parameters.</span>
    <span class="n">vds_load_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;test&quot;</span><span class="p">:</span> <span class="n">test_dataset</span><span class="p">,</span>
        <span class="s2">&quot;filter_partitions&quot;</span><span class="p">:</span> <span class="n">test_partitions</span><span class="p">,</span>
        <span class="s2">&quot;autosomes_only&quot;</span><span class="p">:</span> <span class="n">autosomes_only</span><span class="p">,</span>
        <span class="s2">&quot;sex_chr_only&quot;</span><span class="p">:</span> <span class="n">sex_chr_only</span><span class="p">,</span>
        <span class="s2">&quot;filter_intervals&quot;</span><span class="p">:</span> <span class="n">filter_intervals</span><span class="p">,</span>
        <span class="s2">&quot;annotate_meta&quot;</span><span class="p">:</span> <span class="ow">not</span> <span class="n">autosomes_only</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting per-sample stats pipeline for </span><span class="si">%s</span><span class="s2">...&quot;</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">create_filter_group</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Creating Table of filter groups for </span><span class="si">%s</span><span class="s2"> summary stats...&quot;</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">per_sample_stats_resources</span><span class="o">.</span><span class="n">create_filter_group</span>
            <span class="n">res</span><span class="o">.</span><span class="n">check_resource_existence</span><span class="p">()</span>

            <span class="n">ht</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">release_ht</span><span class="o">.</span><span class="n">ht</span><span class="p">()</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">_filter_partitions</span><span class="p">(</span><span class="n">test_partitions</span><span class="p">)</span> <span class="k">if</span> <span class="n">test_partitions</span> <span class="k">else</span> <span class="n">ht</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter_intervals</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">filter_intervals</span><span class="p">)</span> <span class="k">if</span> <span class="n">test_gene</span> <span class="k">else</span> <span class="n">ht</span>

            <span class="n">get_summary_stats_filter_groups_ht</span><span class="p">(</span>
                <span class="n">ht</span><span class="p">,</span>
                <span class="n">capture_regions</span><span class="o">=</span><span class="n">exomes</span><span class="p">,</span>
                <span class="n">vep_canonical</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">vep_canonical</span><span class="p">,</span>
                <span class="n">vep_mane</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">vep_mane</span><span class="p">,</span>
                <span class="n">rare_variants_afs</span><span class="o">=</span><span class="n">rare_variants_afs</span><span class="p">,</span>
                <span class="n">rare_variants_grpmax</span><span class="o">=</span><span class="n">rare_variants_grpmax</span><span class="p">,</span>
                <span class="n">rare_variant_mode</span><span class="o">=</span><span class="n">run_rare_variant_mode</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">filter_groups_ht</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">create_intermediate</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Creating intermediate MatrixTable for per-sample counts...&quot;</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">per_sample_stats_resources</span><span class="o">.</span><span class="n">create_intermediate</span>
            <span class="n">res</span><span class="o">.</span><span class="n">check_resource_existence</span><span class="p">()</span>

            <span class="n">create_intermediate_mt_for_sample_counts</span><span class="p">(</span>
                <span class="n">load_mt_for_sample_counts</span><span class="p">(</span>
                    <span class="n">data_type</span><span class="p">,</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">filter_groups_ht</span><span class="o">.</span><span class="n">ht</span><span class="p">(),</span>
                    <span class="n">adjust_ploidy</span><span class="o">=</span><span class="ow">not</span> <span class="n">autosomes_only</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">vds_load_params</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">temp_intermediate_ht</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="n">per_sample_ht</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">per_sample_ht_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">create_per_sample_counts</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating per-sample variant statistics for </span><span class="si">%s</span><span class="s2">...&quot;</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">per_sample_stats_resources</span><span class="o">.</span><span class="n">create_per_sample_counts</span>
            <span class="n">res</span><span class="o">.</span><span class="n">check_resource_existence</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">use_intermediate</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using intermediate MatrixTable for per-sample counts...&quot;</span><span class="p">)</span>
                <span class="n">ht</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">temp_intermediate_ht</span><span class="o">.</span><span class="n">ht</span><span class="p">()</span>
                <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">_filter_partitions</span><span class="p">(</span><span class="n">test_partitions</span><span class="p">)</span> <span class="k">if</span> <span class="n">test_partitions</span> <span class="k">else</span> <span class="n">ht</span>
                <span class="n">ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter_intervals</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">filter_intervals</span><span class="p">)</span> <span class="k">if</span> <span class="n">test_gene</span> <span class="k">else</span> <span class="n">ht</span>
                <span class="n">ht</span> <span class="o">=</span> <span class="n">create_per_sample_counts_from_intermediate_ht</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ht</span> <span class="o">=</span> <span class="n">create_per_sample_counts_ht</span><span class="p">(</span>
                    <span class="n">load_mt_for_sample_counts</span><span class="p">(</span>
                        <span class="n">data_type</span><span class="p">,</span>
                        <span class="n">res</span><span class="o">.</span><span class="n">filter_groups_ht</span><span class="o">.</span><span class="n">ht</span><span class="p">(),</span>
                        <span class="n">adjust_ploidy</span><span class="o">=</span><span class="ow">not</span> <span class="n">autosomes_only</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">vds_load_params</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

            <span class="n">per_sample_ht</span> <span class="o">=</span> <span class="n">ht</span>
            <span class="n">per_sample_ht_path</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">per_sample_ht</span><span class="o">.</span><span class="n">path</span>

        <span class="k">if</span> <span class="n">test</span> <span class="ow">and</span> <span class="p">(</span><span class="n">combine_chr_stats</span> <span class="ow">or</span> <span class="n">aggregate_stats</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Testing: Using whatever per-sample counts testing Table(s) was most &quot;</span>
                <span class="s2">&quot;recently created.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">combine_chr_stats</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Combining per-sample stats for autosomes with per-sample stats for &quot;</span>
                <span class="s2">&quot;sex chromosomes...&quot;</span>
            <span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">per_sample_stats_resources</span><span class="o">.</span><span class="n">combine_stats</span>
            <span class="n">res</span><span class="o">.</span><span class="n">check_resource_existence</span><span class="p">()</span>

            <span class="n">per_sample_ht</span> <span class="o">=</span> <span class="n">combine_autosome_and_sex_chr_stats</span><span class="p">(</span>
                <span class="n">res</span><span class="o">.</span><span class="n">autosomes_ht</span><span class="o">.</span><span class="n">ht</span><span class="p">(),</span> <span class="n">res</span><span class="o">.</span><span class="n">sex_chr_ht</span><span class="o">.</span><span class="n">ht</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">per_sample_ht_path</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">per_sample_ht</span><span class="o">.</span><span class="n">path</span>

        <span class="k">if</span> <span class="n">per_sample_ht</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Set &#39;y_nonpar&#39; sample stats to missing for XX individuals if not autosomes</span>
            <span class="c1"># only.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">autosomes_only</span><span class="p">:</span>
                <span class="n">sex_karyotype</span> <span class="o">=</span> <span class="n">meta_ht</span><span class="p">[</span><span class="n">per_sample_ht</span><span class="o">.</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">sex_imputation</span><span class="o">.</span><span class="n">sex_karyotype</span>
                <span class="n">missing_ss</span> <span class="o">=</span> <span class="n">missing_struct_expr</span><span class="p">(</span>
                    <span class="n">per_sample_ht</span><span class="o">.</span><span class="n">summary_stats</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">element_type</span>
                <span class="p">)</span>
                <span class="n">per_sample_ht</span> <span class="o">=</span> <span class="n">per_sample_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                    <span class="n">summary_stats</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">sex_karyotype</span> <span class="o">==</span> <span class="s2">&quot;XX&quot;</span><span class="p">)</span>
                        <span class="o">&amp;</span> <span class="p">(</span><span class="n">per_sample_ht</span><span class="o">.</span><span class="n">sex_chr_nonpar_group</span> <span class="o">==</span> <span class="s2">&quot;y_nonpar&quot;</span><span class="p">),</span>
                        <span class="n">per_sample_ht</span><span class="o">.</span><span class="n">summary_stats</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">missing_ss</span><span class="p">),</span>
                        <span class="n">per_sample_ht</span><span class="o">.</span><span class="n">summary_stats</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">per_sample_ht</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">per_sample_ht_path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">aggregate_stats</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing aggregate sample statistics...&quot;</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">per_sample_stats_resources</span><span class="o">.</span><span class="n">aggregate_stats</span>
            <span class="n">res</span><span class="o">.</span><span class="n">check_resource_existence</span><span class="p">()</span>

            <span class="n">compute_agg_sample_stats</span><span class="p">(</span>
                <span class="n">res</span><span class="o">.</span><span class="n">per_sample_ht</span><span class="o">.</span><span class="n">ht</span><span class="p">(),</span>
                <span class="n">meta_ht</span><span class="p">,</span>
                <span class="n">by_ancestry</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">by_ancestry</span><span class="p">,</span>
                <span class="n">by_subset</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">by_subset</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">per_sample_agg_ht</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Copying log to logging bucket...&quot;</span><span class="p">)</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">copy_log</span><span class="p">(</span><span class="n">get_logging_path</span><span class="p">(</span><span class="s2">&quot;per_sample_stats&quot;</span><span class="p">))</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;-o&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--overwrite&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Overwrite data (default: False)&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--slack-channel&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Slack channel to post results and notifications to.&quot;</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--test-gene&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Filter Tables/VDS to only the PCSK9 and/or TRPC5 and ZFY genes for &quot;</span>
            <span class="s2">&quot;testing. Recommended for a quick test (if used with --test-dataset) that &quot;</span>
            <span class="s2">&quot;the full pipeline is working. This is not recommended for testing &quot;</span>
            <span class="s2">&quot;potential memory errors in --create-per-sample-counts-ht.&quot;</span>
        <span class="p">),</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--test-n-partitions&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Number of partitions to use for testing --create-per-sample-counts-ht. &quot;</span>
            <span class="s2">&quot;Recommended as a quick test of --create-per-sample-counts-ht &quot;</span>
            <span class="s2">&quot;if combined with --test-dataset. It can also be useful as a test for &quot;</span>
            <span class="s2">&quot;memory errors in --create-per-sample-counts-ht when not combined with &quot;</span>
            <span class="s2">&quot;--test-dataset.&quot;</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--test-difficult-partitions&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Whether to test on a set of 4 exome partitions that have been &quot;</span>
            <span class="s2">&quot;particularly difficult and caused memory errors in other parts of the &quot;</span>
            <span class="s2">&quot;QC workflow. Recommended to test for memory errors in &quot;</span>
            <span class="s2">&quot;--create-per-sample-counts-ht.&quot;</span>
        <span class="p">),</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--test-dataset&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Use the test VDS instead of the full VDS. Recommended for testing &quot;</span>
            <span class="s2">&quot;--create-per-sample-counts-ht. Use in combination with --test-gene or&quot;</span>
            <span class="s2">&quot;--test-n-partitions for a quick test of --create-per-sample-counts-ht &quot;</span>
            <span class="s2">&quot;or alone as a test that there are no memory errors when aggregating &quot;</span>
            <span class="s2">&quot;stats for full exomes.&quot;</span>
        <span class="p">),</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--data-type&quot;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="s2">&quot;exomes&quot;</span><span class="p">,</span>
        <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;exomes&quot;</span><span class="p">,</span> <span class="s2">&quot;genomes&quot;</span><span class="p">],</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Data type (exomes or genomes) to produce summary stats for.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--run-rare-variant-mode&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Run in rare variant mode. This will filter to variants with &quot;</span>
            <span class="s2">&quot;AF &lt; max(--rare-variants-afs) or grpmax &lt; max(--rare-variants-grpmax).&quot;</span>
            <span class="s2">&quot;It also uses the max AFs and max grpmax cutoffs as common filters in the &quot;</span>
            <span class="s2">&quot;filter groups to get all filtering stratifications by AF and grpmax &quot;</span>
            <span class="s2">&quot;cutoff.&quot;</span>
        <span class="p">),</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--create-filter-group-ht&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Create Table of filter groups for summary stats.&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--create-intermediate-mt-for-sample-counts&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Create intermediate MatrixTable for per-sample variant counts. The output &quot;</span>
            <span class="s2">&quot;MatrixTable will be written to a temporary location!&quot;</span>
        <span class="p">),</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--create-per-sample-counts-ht&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Create per-sample variant counts Table.&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--use-intermediate-mt-for-sample-counts&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Use intermediate MatrixTable for per-sample variant counts. This is only &quot;</span>
            <span class="s2">&quot;relevant when using --create-per-sample-counts-ht. Note that the this &quot;</span>
            <span class="s2">&quot;step is memory intensive and should be run on a cluster with n1-highmem-8 &quot;</span>
            <span class="s2">&quot;workers. It also requires shuffling, so a cluster with all workers is &quot;</span>
            <span class="s2">&quot;recommended.&quot;</span>
        <span class="p">),</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--combine-autosome-and-sex-chr-stats&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Combine per-sample counts for autosomes with per-sample counts for sex &quot;</span>
            <span class="s2">&quot;chromosomes.&quot;</span>
        <span class="p">),</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--aggregate-sample-stats&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Compute aggregate sample statistics from the per-sample counts and add &quot;</span>
            <span class="s2">&quot;them as globals to the output Table.&quot;</span>
        <span class="p">),</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--autosomes-only-stats&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Whether to restrict per-sample summary stats to autosomes only.&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--sex-chr-only-stats&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Whether to restrict per-sample summary stats to sex chromosomes only.&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--rare-variants-afs&quot;</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">SUM_STAT_FILTERS</span><span class="p">[</span><span class="s2">&quot;max_af&quot;</span><span class="p">],</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The allele frequency threshold to use for rare variants.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--rare-variants-grpmax&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;The genetic ancestry group max allele frequency threshold to use for rare variants.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--vep-canonical&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Whether to filter to only canonical transcripts. when using --by-csqs.&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--vep-mane&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Whether to filter to only MANE transcripts. when using --by-csqs.&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--by-ancestry&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Output statistics for number of singletons, n_het, and n_hom by inferred &quot;</span>
            <span class="s2">&quot;genetic ancestry group. Only relevant when using &quot;</span>
            <span class="s2">&quot;--compute-aggregate-sample-stats&quot;</span>
        <span class="p">),</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--by-subset&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">&quot;Get aggregate statistics for the whole dataset and for ukb and non-ukb &quot;</span>
            <span class="s2">&quot;subsets. This is only working on exomes data type.&quot;</span>
        <span class="p">),</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">&quot;--custom-suffix&quot;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Custom string to append to output names.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">slack_channel</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">slack_notifications</span><span class="p">(</span><span class="n">slack_token</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">slack_channel</span><span class="p">):</span>
            <span class="n">main</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">main</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>